"use strict";const utils=require("@typescript-eslint/utils"),n$4=require("typescript"),node_path=require("node:path"),node_module=require("node:module"),scopeManager=require("@typescript-eslint/scope-manager");var _documentCurrentScript=typeof document<"u"?document.currentScript:null;function _interopDefaultCompat(e){return e&&typeof e=="object"&&"default"in e?e.default:e}const n__default=_interopDefaultCompat(n$4),version="1.3.20",createEslintRule=utils.ESLintUtils.RuleCreator(e=>`https://github.com/vitest-dev/eslint-plugin-vitest/blob/main/docs/rules/${e}.md`),joinNames=(e,b)=>e&&b?`${e}.${b}`:null,isFunction=e=>e.type===utils.AST_NODE_TYPES.FunctionExpression||e.type===utils.AST_NODE_TYPES.ArrowFunctionExpression;function getNodeName(e){if(isSupportedAccessor(e))return getAccessorValue(e);switch(e.type){case utils.AST_NODE_TYPES.TaggedTemplateExpression:return getNodeName(e.tag);case utils.AST_NODE_TYPES.MemberExpression:return joinNames(getNodeName(e.object),getNodeName(e.property));case utils.AST_NODE_TYPES.NewExpression:case utils.AST_NODE_TYPES.CallExpression:return getNodeName(e.callee)}return null}const isSupportedAccessor=(e,b)=>isIdentifier(e,b)||isStringNode(e,b),isIdentifier=(e,b)=>e.type===utils.AST_NODE_TYPES.Identifier&&(b===void 0||e.name===b),S$6=(e,b)=>e.type===utils.AST_NODE_TYPES.TemplateLiteral&&e.quasis.length===1&&(b===void 0||e.quasis[0].value.raw===b),g$4=(e,b)=>e.type===utils.AST_NODE_TYPES.Literal&&typeof e.value=="string"&&(b===void 0||e.value===b),isStringNode=(e,b)=>g$4(e,b)||S$6(e,b),getAccessorValue=e=>e.type===utils.AST_NODE_TYPES.Identifier?e.name:getStringValue(e),getStringValue=e=>e?.type===utils.AST_NODE_TYPES.TemplateLiteral?e.quasis[0].value.raw:e?.value,replaceAccessorFixer=(e,b,d)=>e.replaceText(b,b.type===utils.AST_NODE_TYPES.Identifier?d:`'${d}'`),removeExtraArgumentsFixer=(e,b,d,Y)=>{const q=d.arguments[Y],$=d.arguments[d.arguments.length-1],{sourceCode:F}=b;let V=F.getTokenAfter($);return V.value===","&&(V=F.getTokenAfter(V)),e.removeRange([q.range[0],V.range[0]])},isParsedInstanceOfMatcherCall=(e,b)=>getAccessorValue(e.matcher)==="toBeInstanceOf"&&e.args.length===1&&isSupportedAccessor(e.args[0],b);var UtilName=(e=>(e.vi="vi",e.vitest="vitest",e))(UtilName||{}),DescribeAlias=(e=>(e.describe="describe",e.fdescribe="fdescribe",e.xdescribe="xdescribe",e))(DescribeAlias||{}),TestCaseName=(e=>(e.fit="fit",e.it="it",e.test="test",e.xit="xit",e.xtest="xtest",e.bench="bench",e))(TestCaseName||{}),HookName=(e=>(e.beforeAll="beforeAll",e.beforeEach="beforeEach",e.afterAll="afterAll",e.afterEach="afterEach",e))(HookName||{}),ModifierName=(e=>(e.to="to",e.have="have",e.not="not",e.rejects="rejects",e.resolves="resolves",e.returns="returns",e.branded="branded",e.asserts="asserts",e.constructorParameters="constructorParameters",e.parameters="parameters",e.thisParameter="thisParameter",e.guards="guards",e.instance="instance",e.items="items",e))(ModifierName||{}),EqualityMatcher=(e=>(e.toBe="toBe",e.toEqual="toEqual",e.toStrictEqual="toStrictEqual",e))(EqualityMatcher||{});function isClassOrFunctionType(e){return e.getCallSignatures().length>0?!0:e.getSymbol()?.getDeclarations()?.some(b=>n__default.isArrowFunction(b)||n__default.isClassDeclaration(b)||n__default.isClassExpression(b)||n__default.isFunctionDeclaration(b)||n__default.isFunctionExpression(b)||n__default.isMethodDeclaration(b)||n__default.isFunctionTypeNode(b))??!1}const ValidVitestFnCallChains=new Set(["beforeEach","beforeAll","afterEach","afterAll","it","it.skip","it.only","it.concurrent","it.sequential","it.todo","it.fails","it.extend","it.skipIf","it.runIf","it.each","it.skip.only","it.skip.concurrent","it.skip.sequential","it.skip.todo","it.skip.fails","it.only.skip","it.only.concurrent","it.only.sequential","it.only.todo","it.only.fails","it.concurrent.skip","it.concurrent.only","it.concurrent.sequential","it.concurrent.todo","it.concurrent.fails","it.sequential.skip","it.sequential.only","it.sequential.concurrent","it.sequential.todo","it.sequential.fails","it.todo.skip","it.todo.only","it.todo.concurrent","it.todo.sequential","it.todo.fails","it.fails.skip","it.fails.only","it.fails.concurrent","it.fails.sequential","it.fails.todo","it.extend.skip","it.extend.only","it.extend.concurrent","it.extend.sequential","it.extend.todo","it.extend.fails","it.skipIf.skip","it.skipIf.only","it.skipIf.concurrent","it.skipIf.sequential","it.skipIf.todo","it.skipIf.fails","it.runIf.skip","it.runIf.only","it.runIf.concurrent","it.runIf.sequential","it.runIf.todo","it.runIf.fails","it.skip.each","it.only.each","it.concurrent.each","it.sequential.each","it.todo.each","it.fails.each","it.extend.skipIf","it.extend.runIf","it.extend.each","it.skipIf.each","it.runIf.each","it.skip.only.concurrent","it.skip.only.sequential","it.skip.only.todo","it.skip.only.fails","it.skip.concurrent.only","it.skip.concurrent.sequential","it.skip.concurrent.todo","it.skip.concurrent.fails","it.skip.sequential.only","it.skip.sequential.concurrent","it.skip.sequential.todo","it.skip.sequential.fails","it.skip.todo.only","it.skip.todo.concurrent","it.skip.todo.sequential","it.skip.todo.fails","it.skip.fails.only","it.skip.fails.concurrent","it.skip.fails.sequential","it.skip.fails.todo","it.only.skip.concurrent","it.only.skip.sequential","it.only.skip.todo","it.only.skip.fails","it.only.concurrent.skip","it.only.concurrent.sequential","it.only.concurrent.todo","it.only.concurrent.fails","it.only.sequential.skip","it.only.sequential.concurrent","it.only.sequential.todo","it.only.sequential.fails","it.only.todo.skip","it.only.todo.concurrent","it.only.todo.sequential","it.only.todo.fails","it.only.fails.skip","it.only.fails.concurrent","it.only.fails.sequential","it.only.fails.todo","it.concurrent.skip.only","it.concurrent.skip.sequential","it.concurrent.skip.todo","it.concurrent.skip.fails","it.concurrent.only.skip","it.concurrent.only.sequential","it.concurrent.only.todo","it.concurrent.only.fails","it.concurrent.sequential.skip","it.concurrent.sequential.only","it.concurrent.sequential.todo","it.concurrent.sequential.fails","it.concurrent.todo.skip","it.concurrent.todo.only","it.concurrent.todo.sequential","it.concurrent.todo.fails","it.concurrent.fails.skip","it.concurrent.fails.only","it.concurrent.fails.sequential","it.concurrent.fails.todo","it.sequential.skip.only","it.sequential.skip.concurrent","it.sequential.skip.todo","it.sequential.skip.fails","it.sequential.only.skip","it.sequential.only.concurrent","it.sequential.only.todo","it.sequential.only.fails","it.sequential.concurrent.skip","it.sequential.concurrent.only","it.sequential.concurrent.todo","it.sequential.concurrent.fails","it.sequential.todo.skip","it.sequential.todo.only","it.sequential.todo.concurrent","it.sequential.todo.fails","it.sequential.fails.skip","it.sequential.fails.only","it.sequential.fails.concurrent","it.sequential.fails.todo","it.todo.skip.only","it.todo.skip.concurrent","it.todo.skip.sequential","it.todo.skip.fails","it.todo.only.skip","it.todo.only.concurrent","it.todo.only.sequential","it.todo.only.fails","it.todo.concurrent.skip","it.todo.concurrent.only","it.todo.concurrent.sequential","it.todo.concurrent.fails","it.todo.sequential.skip","it.todo.sequential.only","it.todo.sequential.concurrent","it.todo.sequential.fails","it.todo.fails.skip","it.todo.fails.only","it.todo.fails.concurrent","it.todo.fails.sequential","it.fails.skip.only","it.fails.skip.concurrent","it.fails.skip.sequential","it.fails.skip.todo","it.fails.only.skip","it.fails.only.concurrent","it.fails.only.sequential","it.fails.only.todo","it.fails.concurrent.skip","it.fails.concurrent.only","it.fails.concurrent.sequential","it.fails.concurrent.todo","it.fails.sequential.skip","it.fails.sequential.only","it.fails.sequential.concurrent","it.fails.sequential.todo","it.fails.todo.skip","it.fails.todo.only","it.fails.todo.concurrent","it.fails.todo.sequential","it.extend.skip.only","it.extend.skip.concurrent","it.extend.skip.sequential","it.extend.skip.todo","it.extend.skip.fails","it.extend.only.skip","it.extend.only.concurrent","it.extend.only.sequential","it.extend.only.todo","it.extend.only.fails","it.extend.concurrent.skip","it.extend.concurrent.only","it.extend.concurrent.sequential","it.extend.concurrent.todo","it.extend.concurrent.fails","it.extend.sequential.skip","it.extend.sequential.only","it.extend.sequential.concurrent","it.extend.sequential.todo","it.extend.sequential.fails","it.extend.todo.skip","it.extend.todo.only","it.extend.todo.concurrent","it.extend.todo.sequential","it.extend.todo.fails","it.extend.fails.skip","it.extend.fails.only","it.extend.fails.concurrent","it.extend.fails.sequential","it.extend.fails.todo","it.skipIf.skip.only","it.skipIf.skip.concurrent","it.skipIf.skip.sequential","it.skipIf.skip.todo","it.skipIf.skip.fails","it.skipIf.only.skip","it.skipIf.only.concurrent","it.skipIf.only.sequential","it.skipIf.only.todo","it.skipIf.only.fails","it.skipIf.concurrent.skip","it.skipIf.concurrent.only","it.skipIf.concurrent.sequential","it.skipIf.concurrent.todo","it.skipIf.concurrent.fails","it.skipIf.sequential.skip","it.skipIf.sequential.only","it.skipIf.sequential.concurrent","it.skipIf.sequential.todo","it.skipIf.sequential.fails","it.skipIf.todo.skip","it.skipIf.todo.only","it.skipIf.todo.concurrent","it.skipIf.todo.sequential","it.skipIf.todo.fails","it.skipIf.fails.skip","it.skipIf.fails.only","it.skipIf.fails.concurrent","it.skipIf.fails.sequential","it.skipIf.fails.todo","it.runIf.skip.only","it.runIf.skip.concurrent","it.runIf.skip.sequential","it.runIf.skip.todo","it.runIf.skip.fails","it.runIf.only.skip","it.runIf.only.concurrent","it.runIf.only.sequential","it.runIf.only.todo","it.runIf.only.fails","it.runIf.concurrent.skip","it.runIf.concurrent.only","it.runIf.concurrent.sequential","it.runIf.concurrent.todo","it.runIf.concurrent.fails","it.runIf.sequential.skip","it.runIf.sequential.only","it.runIf.sequential.concurrent","it.runIf.sequential.todo","it.runIf.sequential.fails","it.runIf.todo.skip","it.runIf.todo.only","it.runIf.todo.concurrent","it.runIf.todo.sequential","it.runIf.todo.fails","it.runIf.fails.skip","it.runIf.fails.only","it.runIf.fails.concurrent","it.runIf.fails.sequential","it.runIf.fails.todo","it.skip.only.each","it.skip.concurrent.each","it.skip.sequential.each","it.skip.todo.each","it.skip.fails.each","it.only.skip.each","it.only.concurrent.each","it.only.sequential.each","it.only.todo.each","it.only.fails.each","it.concurrent.skip.each","it.concurrent.only.each","it.concurrent.sequential.each","it.concurrent.todo.each","it.concurrent.fails.each","it.sequential.skip.each","it.sequential.only.each","it.sequential.concurrent.each","it.sequential.todo.each","it.sequential.fails.each","it.todo.skip.each","it.todo.only.each","it.todo.concurrent.each","it.todo.sequential.each","it.todo.fails.each","it.fails.skip.each","it.fails.only.each","it.fails.concurrent.each","it.fails.sequential.each","it.fails.todo.each","it.extend.skipIf.skip","it.extend.skipIf.only","it.extend.skipIf.concurrent","it.extend.skipIf.sequential","it.extend.skipIf.todo","it.extend.skipIf.fails","it.extend.runIf.skip","it.extend.runIf.only","it.extend.runIf.concurrent","it.extend.runIf.sequential","it.extend.runIf.todo","it.extend.runIf.fails","it.extend.skip.each","it.extend.only.each","it.extend.concurrent.each","it.extend.sequential.each","it.extend.todo.each","it.extend.fails.each","it.skipIf.skip.each","it.skipIf.only.each","it.skipIf.concurrent.each","it.skipIf.sequential.each","it.skipIf.todo.each","it.skipIf.fails.each","it.runIf.skip.each","it.runIf.only.each","it.runIf.concurrent.each","it.runIf.sequential.each","it.runIf.todo.each","it.runIf.fails.each","it.extend.skipIf.each","it.extend.runIf.each","test","test.skip","test.only","test.concurrent","test.sequential","test.todo","test.fails","test.extend","test.skipIf","test.runIf","test.each","test.skip.only","test.skip.concurrent","test.skip.sequential","test.skip.todo","test.skip.fails","test.only.skip","test.only.concurrent","test.only.sequential","test.only.todo","test.only.fails","test.concurrent.skip","test.concurrent.only","test.concurrent.sequential","test.concurrent.todo","test.concurrent.fails","test.sequential.skip","test.sequential.only","test.sequential.concurrent","test.sequential.todo","test.sequential.fails","test.todo.skip","test.todo.only","test.todo.concurrent","test.todo.sequential","test.todo.fails","test.fails.skip","test.fails.only","test.fails.concurrent","test.fails.sequential","test.fails.todo","test.extend.skip","test.extend.only","test.extend.concurrent","test.extend.sequential","test.extend.todo","test.extend.fails","test.skipIf.skip","test.skipIf.only","test.skipIf.concurrent","test.skipIf.sequential","test.skipIf.todo","test.skipIf.fails","test.runIf.skip","test.runIf.only","test.runIf.concurrent","test.runIf.sequential","test.runIf.todo","test.runIf.fails","test.skip.each","test.only.each","test.concurrent.each","test.sequential.each","test.todo.each","test.fails.each","test.extend.skipIf","test.extend.runIf","test.extend.each","test.skipIf.each","test.runIf.each","test.skip.only.concurrent","test.skip.only.sequential","test.skip.only.todo","test.skip.only.fails","test.skip.concurrent.only","test.skip.concurrent.sequential","test.skip.concurrent.todo","test.skip.concurrent.fails","test.skip.sequential.only","test.skip.sequential.concurrent","test.skip.sequential.todo","test.skip.sequential.fails","test.skip.todo.only","test.skip.todo.concurrent","test.skip.todo.sequential","test.skip.todo.fails","test.skip.fails.only","test.skip.fails.concurrent","test.skip.fails.sequential","test.skip.fails.todo","test.only.skip.concurrent","test.only.skip.sequential","test.only.skip.todo","test.only.skip.fails","test.only.concurrent.skip","test.only.concurrent.sequential","test.only.concurrent.todo","test.only.concurrent.fails","test.only.sequential.skip","test.only.sequential.concurrent","test.only.sequential.todo","test.only.sequential.fails","test.only.todo.skip","test.only.todo.concurrent","test.only.todo.sequential","test.only.todo.fails","test.only.fails.skip","test.only.fails.concurrent","test.only.fails.sequential","test.only.fails.todo","test.concurrent.skip.only","test.concurrent.skip.sequential","test.concurrent.skip.todo","test.concurrent.skip.fails","test.concurrent.only.skip","test.concurrent.only.sequential","test.concurrent.only.todo","test.concurrent.only.fails","test.concurrent.sequential.skip","test.concurrent.sequential.only","test.concurrent.sequential.todo","test.concurrent.sequential.fails","test.concurrent.todo.skip","test.concurrent.todo.only","test.concurrent.todo.sequential","test.concurrent.todo.fails","test.concurrent.fails.skip","test.concurrent.fails.only","test.concurrent.fails.sequential","test.concurrent.fails.todo","test.sequential.skip.only","test.sequential.skip.concurrent","test.sequential.skip.todo","test.sequential.skip.fails","test.sequential.only.skip","test.sequential.only.concurrent","test.sequential.only.todo","test.sequential.only.fails","test.sequential.concurrent.skip","test.sequential.concurrent.only","test.sequential.concurrent.todo","test.sequential.concurrent.fails","test.sequential.todo.skip","test.sequential.todo.only","test.sequential.todo.concurrent","test.sequential.todo.fails","test.sequential.fails.skip","test.sequential.fails.only","test.sequential.fails.concurrent","test.sequential.fails.todo","test.todo.skip.only","test.todo.skip.concurrent","test.todo.skip.sequential","test.todo.skip.fails","test.todo.only.skip","test.todo.only.concurrent","test.todo.only.sequential","test.todo.only.fails","test.todo.concurrent.skip","test.todo.concurrent.only","test.todo.concurrent.sequential","test.todo.concurrent.fails","test.todo.sequential.skip","test.todo.sequential.only","test.todo.sequential.concurrent","test.todo.sequential.fails","test.todo.fails.skip","test.todo.fails.only","test.todo.fails.concurrent","test.todo.fails.sequential","test.fails.skip.only","test.fails.skip.concurrent","test.fails.skip.sequential","test.fails.skip.todo","test.fails.only.skip","test.fails.only.concurrent","test.fails.only.sequential","test.fails.only.todo","test.fails.concurrent.skip","test.fails.concurrent.only","test.fails.concurrent.sequential","test.fails.concurrent.todo","test.fails.sequential.skip","test.fails.sequential.only","test.fails.sequential.concurrent","test.fails.sequential.todo","test.fails.todo.skip","test.fails.todo.only","test.fails.todo.concurrent","test.fails.todo.sequential","test.extend.skip.only","test.extend.skip.concurrent","test.extend.skip.sequential","test.extend.skip.todo","test.extend.skip.fails","test.extend.only.skip","test.extend.only.concurrent","test.extend.only.sequential","test.extend.only.todo","test.extend.only.fails","test.extend.concurrent.skip","test.extend.concurrent.only","test.extend.concurrent.sequential","test.extend.concurrent.todo","test.extend.concurrent.fails","test.extend.sequential.skip","test.extend.sequential.only","test.extend.sequential.concurrent","test.extend.sequential.todo","test.extend.sequential.fails","test.extend.todo.skip","test.extend.todo.only","test.extend.todo.concurrent","test.extend.todo.sequential","test.extend.todo.fails","test.extend.fails.skip","test.extend.fails.only","test.extend.fails.concurrent","test.extend.fails.sequential","test.extend.fails.todo","test.skipIf.skip.only","test.skipIf.skip.concurrent","test.skipIf.skip.sequential","test.skipIf.skip.todo","test.skipIf.skip.fails","test.skipIf.only.skip","test.skipIf.only.concurrent","test.skipIf.only.sequential","test.skipIf.only.todo","test.skipIf.only.fails","test.skipIf.concurrent.skip","test.skipIf.concurrent.only","test.skipIf.concurrent.sequential","test.skipIf.concurrent.todo","test.skipIf.concurrent.fails","test.skipIf.sequential.skip","test.skipIf.sequential.only","test.skipIf.sequential.concurrent","test.skipIf.sequential.todo","test.skipIf.sequential.fails","test.skipIf.todo.skip","test.skipIf.todo.only","test.skipIf.todo.concurrent","test.skipIf.todo.sequential","test.skipIf.todo.fails","test.skipIf.fails.skip","test.skipIf.fails.only","test.skipIf.fails.concurrent","test.skipIf.fails.sequential","test.skipIf.fails.todo","test.runIf.skip.only","test.runIf.skip.concurrent","test.runIf.skip.sequential","test.runIf.skip.todo","test.runIf.skip.fails","test.runIf.only.skip","test.runIf.only.concurrent","test.runIf.only.sequential","test.runIf.only.todo","test.runIf.only.fails","test.runIf.concurrent.skip","test.runIf.concurrent.only","test.runIf.concurrent.sequential","test.runIf.concurrent.todo","test.runIf.concurrent.fails","test.runIf.sequential.skip","test.runIf.sequential.only","test.runIf.sequential.concurrent","test.runIf.sequential.todo","test.runIf.sequential.fails","test.runIf.todo.skip","test.runIf.todo.only","test.runIf.todo.concurrent","test.runIf.todo.sequential","test.runIf.todo.fails","test.runIf.fails.skip","test.runIf.fails.only","test.runIf.fails.concurrent","test.runIf.fails.sequential","test.runIf.fails.todo","test.skip.only.each","test.skip.concurrent.each","test.skip.sequential.each","test.skip.todo.each","test.skip.fails.each","test.only.skip.each","test.only.concurrent.each","test.only.sequential.each","test.only.todo.each","test.only.fails.each","test.concurrent.skip.each","test.concurrent.only.each","test.concurrent.sequential.each","test.concurrent.todo.each","test.concurrent.fails.each","test.sequential.skip.each","test.sequential.only.each","test.sequential.concurrent.each","test.sequential.todo.each","test.sequential.fails.each","test.todo.skip.each","test.todo.only.each","test.todo.concurrent.each","test.todo.sequential.each","test.todo.fails.each","test.fails.skip.each","test.fails.only.each","test.fails.concurrent.each","test.fails.sequential.each","test.fails.todo.each","test.extend.skipIf.skip","test.extend.skipIf.only","test.extend.skipIf.concurrent","test.extend.skipIf.sequential","test.extend.skipIf.todo","test.extend.skipIf.fails","test.extend.runIf.skip","test.extend.runIf.only","test.extend.runIf.concurrent","test.extend.runIf.sequential","test.extend.runIf.todo","test.extend.runIf.fails","test.extend.skip.each","test.extend.only.each","test.extend.concurrent.each","test.extend.sequential.each","test.extend.todo.each","test.extend.fails.each","test.skipIf.skip.each","test.skipIf.only.each","test.skipIf.concurrent.each","test.skipIf.sequential.each","test.skipIf.todo.each","test.skipIf.fails.each","test.runIf.skip.each","test.runIf.only.each","test.runIf.concurrent.each","test.runIf.sequential.each","test.runIf.todo.each","test.runIf.fails.each","test.extend.skipIf.each","test.extend.runIf.each","bench","bench.skip","bench.only","bench.todo","bench.skipIf","bench.runIf","bench.skip.only","bench.skip.todo","bench.only.skip","bench.only.todo","bench.todo.skip","bench.todo.only","bench.skipIf.skip","bench.skipIf.only","bench.skipIf.todo","bench.runIf.skip","bench.runIf.only","bench.runIf.todo","bench.skip.only.todo","bench.skip.todo.only","bench.only.skip.todo","bench.only.todo.skip","bench.todo.skip.only","bench.todo.only.skip","bench.skipIf.skip.only","bench.skipIf.skip.todo","bench.skipIf.only.skip","bench.skipIf.only.todo","bench.skipIf.todo.skip","bench.skipIf.todo.only","bench.runIf.skip.only","bench.runIf.skip.todo","bench.runIf.only.skip","bench.runIf.only.todo","bench.runIf.todo.skip","bench.runIf.todo.only","describe","describe.skip","describe.only","describe.concurrent","describe.sequential","describe.shuffle","describe.todo","describe.skipIf","describe.runIf","describe.each","describe.skip.only","describe.skip.concurrent","describe.skip.sequential","describe.skip.shuffle","describe.skip.todo","describe.only.skip","describe.only.concurrent","describe.only.sequential","describe.only.shuffle","describe.only.todo","describe.concurrent.skip","describe.concurrent.only","describe.concurrent.sequential","describe.concurrent.shuffle","describe.concurrent.todo","describe.sequential.skip","describe.sequential.only","describe.sequential.concurrent","describe.sequential.shuffle","describe.sequential.todo","describe.shuffle.skip","describe.shuffle.only","describe.shuffle.concurrent","describe.shuffle.sequential","describe.shuffle.todo","describe.todo.skip","describe.todo.only","describe.todo.concurrent","describe.todo.sequential","describe.todo.shuffle","describe.skipIf.skip","describe.skipIf.only","describe.skipIf.concurrent","describe.skipIf.sequential","describe.skipIf.shuffle","describe.skipIf.todo","describe.runIf.skip","describe.runIf.only","describe.runIf.concurrent","describe.runIf.sequential","describe.runIf.shuffle","describe.runIf.todo","describe.skip.each","describe.only.each","describe.concurrent.each","describe.sequential.each","describe.shuffle.each","describe.todo.each","describe.skipIf.each","describe.runIf.each","describe.skip.only.concurrent","describe.skip.only.sequential","describe.skip.only.shuffle","describe.skip.only.todo","describe.skip.concurrent.only","describe.skip.concurrent.sequential","describe.skip.concurrent.shuffle","describe.skip.concurrent.todo","describe.skip.sequential.only","describe.skip.sequential.concurrent","describe.skip.sequential.shuffle","describe.skip.sequential.todo","describe.skip.shuffle.only","describe.skip.shuffle.concurrent","describe.skip.shuffle.sequential","describe.skip.shuffle.todo","describe.skip.todo.only","describe.skip.todo.concurrent","describe.skip.todo.sequential","describe.skip.todo.shuffle","describe.only.skip.concurrent","describe.only.skip.sequential","describe.only.skip.shuffle","describe.only.skip.todo","describe.only.concurrent.skip","describe.only.concurrent.sequential","describe.only.concurrent.shuffle","describe.only.concurrent.todo","describe.only.sequential.skip","describe.only.sequential.concurrent","describe.only.sequential.shuffle","describe.only.sequential.todo","describe.only.shuffle.skip","describe.only.shuffle.concurrent","describe.only.shuffle.sequential","describe.only.shuffle.todo","describe.only.todo.skip","describe.only.todo.concurrent","describe.only.todo.sequential","describe.only.todo.shuffle","describe.concurrent.skip.only","describe.concurrent.skip.sequential","describe.concurrent.skip.shuffle","describe.concurrent.skip.todo","describe.concurrent.only.skip","describe.concurrent.only.sequential","describe.concurrent.only.shuffle","describe.concurrent.only.todo","describe.concurrent.sequential.skip","describe.concurrent.sequential.only","describe.concurrent.sequential.shuffle","describe.concurrent.sequential.todo","describe.concurrent.shuffle.skip","describe.concurrent.shuffle.only","describe.concurrent.shuffle.sequential","describe.concurrent.shuffle.todo","describe.concurrent.todo.skip","describe.concurrent.todo.only","describe.concurrent.todo.sequential","describe.concurrent.todo.shuffle","describe.sequential.skip.only","describe.sequential.skip.concurrent","describe.sequential.skip.shuffle","describe.sequential.skip.todo","describe.sequential.only.skip","describe.sequential.only.concurrent","describe.sequential.only.shuffle","describe.sequential.only.todo","describe.sequential.concurrent.skip","describe.sequential.concurrent.only","describe.sequential.concurrent.shuffle","describe.sequential.concurrent.todo","describe.sequential.shuffle.skip","describe.sequential.shuffle.only","describe.sequential.shuffle.concurrent","describe.sequential.shuffle.todo","describe.sequential.todo.skip","describe.sequential.todo.only","describe.sequential.todo.concurrent","describe.sequential.todo.shuffle","describe.shuffle.skip.only","describe.shuffle.skip.concurrent","describe.shuffle.skip.sequential","describe.shuffle.skip.todo","describe.shuffle.only.skip","describe.shuffle.only.concurrent","describe.shuffle.only.sequential","describe.shuffle.only.todo","describe.shuffle.concurrent.skip","describe.shuffle.concurrent.only","describe.shuffle.concurrent.sequential","describe.shuffle.concurrent.todo","describe.shuffle.sequential.skip","describe.shuffle.sequential.only","describe.shuffle.sequential.concurrent","describe.shuffle.sequential.todo","describe.shuffle.todo.skip","describe.shuffle.todo.only","describe.shuffle.todo.concurrent","describe.shuffle.todo.sequential","describe.todo.skip.only","describe.todo.skip.concurrent","describe.todo.skip.sequential","describe.todo.skip.shuffle","describe.todo.only.skip","describe.todo.only.concurrent","describe.todo.only.sequential","describe.todo.only.shuffle","describe.todo.concurrent.skip","describe.todo.concurrent.only","describe.todo.concurrent.sequential","describe.todo.concurrent.shuffle","describe.todo.sequential.skip","describe.todo.sequential.only","describe.todo.sequential.concurrent","describe.todo.sequential.shuffle","describe.todo.shuffle.skip","describe.todo.shuffle.only","describe.todo.shuffle.concurrent","describe.todo.shuffle.sequential","describe.skipIf.skip.only","describe.skipIf.skip.concurrent","describe.skipIf.skip.sequential","describe.skipIf.skip.shuffle","describe.skipIf.skip.todo","describe.skipIf.only.skip","describe.skipIf.only.concurrent","describe.skipIf.only.sequential","describe.skipIf.only.shuffle","describe.skipIf.only.todo","describe.skipIf.concurrent.skip","describe.skipIf.concurrent.only","describe.skipIf.concurrent.sequential","describe.skipIf.concurrent.shuffle","describe.skipIf.concurrent.todo","describe.skipIf.sequential.skip","describe.skipIf.sequential.only","describe.skipIf.sequential.concurrent","describe.skipIf.sequential.shuffle","describe.skipIf.sequential.todo","describe.skipIf.shuffle.skip","describe.skipIf.shuffle.only","describe.skipIf.shuffle.concurrent","describe.skipIf.shuffle.sequential","describe.skipIf.shuffle.todo","describe.skipIf.todo.skip","describe.skipIf.todo.only","describe.skipIf.todo.concurrent","describe.skipIf.todo.sequential","describe.skipIf.todo.shuffle","describe.runIf.skip.only","describe.runIf.skip.concurrent","describe.runIf.skip.sequential","describe.runIf.skip.shuffle","describe.runIf.skip.todo","describe.runIf.only.skip","describe.runIf.only.concurrent","describe.runIf.only.sequential","describe.runIf.only.shuffle","describe.runIf.only.todo","describe.runIf.concurrent.skip","describe.runIf.concurrent.only","describe.runIf.concurrent.sequential","describe.runIf.concurrent.shuffle","describe.runIf.concurrent.todo","describe.runIf.sequential.skip","describe.runIf.sequential.only","describe.runIf.sequential.concurrent","describe.runIf.sequential.shuffle","describe.runIf.sequential.todo","describe.runIf.shuffle.skip","describe.runIf.shuffle.only","describe.runIf.shuffle.concurrent","describe.runIf.shuffle.sequential","describe.runIf.shuffle.todo","describe.runIf.todo.skip","describe.runIf.todo.only","describe.runIf.todo.concurrent","describe.runIf.todo.sequential","describe.runIf.todo.shuffle","describe.skip.only.each","describe.skip.concurrent.each","describe.skip.sequential.each","describe.skip.shuffle.each","describe.skip.todo.each","describe.only.skip.each","describe.only.concurrent.each","describe.only.sequential.each","describe.only.shuffle.each","describe.only.todo.each","describe.concurrent.skip.each","describe.concurrent.only.each","describe.concurrent.sequential.each","describe.concurrent.shuffle.each","describe.concurrent.todo.each","describe.sequential.skip.each","describe.sequential.only.each","describe.sequential.concurrent.each","describe.sequential.shuffle.each","describe.sequential.todo.each","describe.shuffle.skip.each","describe.shuffle.only.each","describe.shuffle.concurrent.each","describe.shuffle.sequential.each","describe.shuffle.todo.each","describe.todo.skip.each","describe.todo.only.each","describe.todo.concurrent.each","describe.todo.sequential.each","describe.todo.shuffle.each","describe.skipIf.skip.each","describe.skipIf.only.each","describe.skipIf.concurrent.each","describe.skipIf.sequential.each","describe.skipIf.shuffle.each","describe.skipIf.todo.each","describe.runIf.skip.each","describe.runIf.only.each","describe.runIf.concurrent.each","describe.runIf.sequential.each","describe.runIf.shuffle.each","describe.runIf.todo.each","suite","suite.skip","suite.only","suite.concurrent","suite.sequential","suite.shuffle","suite.todo","suite.skipIf","suite.runIf","suite.each","suite.skip.only","suite.skip.concurrent","suite.skip.sequential","suite.skip.shuffle","suite.skip.todo","suite.only.skip","suite.only.concurrent","suite.only.sequential","suite.only.shuffle","suite.only.todo","suite.concurrent.skip","suite.concurrent.only","suite.concurrent.sequential","suite.concurrent.shuffle","suite.concurrent.todo","suite.sequential.skip","suite.sequential.only","suite.sequential.concurrent","suite.sequential.shuffle","suite.sequential.todo","suite.shuffle.skip","suite.shuffle.only","suite.shuffle.concurrent","suite.shuffle.sequential","suite.shuffle.todo","suite.todo.skip","suite.todo.only","suite.todo.concurrent","suite.todo.sequential","suite.todo.shuffle","suite.skipIf.skip","suite.skipIf.only","suite.skipIf.concurrent","suite.skipIf.sequential","suite.skipIf.shuffle","suite.skipIf.todo","suite.runIf.skip","suite.runIf.only","suite.runIf.concurrent","suite.runIf.sequential","suite.runIf.shuffle","suite.runIf.todo","suite.skip.each","suite.only.each","suite.concurrent.each","suite.sequential.each","suite.shuffle.each","suite.todo.each","suite.skipIf.each","suite.runIf.each","suite.skip.only.concurrent","suite.skip.only.sequential","suite.skip.only.shuffle","suite.skip.only.todo","suite.skip.concurrent.only","suite.skip.concurrent.sequential","suite.skip.concurrent.shuffle","suite.skip.concurrent.todo","suite.skip.sequential.only","suite.skip.sequential.concurrent","suite.skip.sequential.shuffle","suite.skip.sequential.todo","suite.skip.shuffle.only","suite.skip.shuffle.concurrent","suite.skip.shuffle.sequential","suite.skip.shuffle.todo","suite.skip.todo.only","suite.skip.todo.concurrent","suite.skip.todo.sequential","suite.skip.todo.shuffle","suite.only.skip.concurrent","suite.only.skip.sequential","suite.only.skip.shuffle","suite.only.skip.todo","suite.only.concurrent.skip","suite.only.concurrent.sequential","suite.only.concurrent.shuffle","suite.only.concurrent.todo","suite.only.sequential.skip","suite.only.sequential.concurrent","suite.only.sequential.shuffle","suite.only.sequential.todo","suite.only.shuffle.skip","suite.only.shuffle.concurrent","suite.only.shuffle.sequential","suite.only.shuffle.todo","suite.only.todo.skip","suite.only.todo.concurrent","suite.only.todo.sequential","suite.only.todo.shuffle","suite.concurrent.skip.only","suite.concurrent.skip.sequential","suite.concurrent.skip.shuffle","suite.concurrent.skip.todo","suite.concurrent.only.skip","suite.concurrent.only.sequential","suite.concurrent.only.shuffle","suite.concurrent.only.todo","suite.concurrent.sequential.skip","suite.concurrent.sequential.only","suite.concurrent.sequential.shuffle","suite.concurrent.sequential.todo","suite.concurrent.shuffle.skip","suite.concurrent.shuffle.only","suite.concurrent.shuffle.sequential","suite.concurrent.shuffle.todo","suite.concurrent.todo.skip","suite.concurrent.todo.only","suite.concurrent.todo.sequential","suite.concurrent.todo.shuffle","suite.sequential.skip.only","suite.sequential.skip.concurrent","suite.sequential.skip.shuffle","suite.sequential.skip.todo","suite.sequential.only.skip","suite.sequential.only.concurrent","suite.sequential.only.shuffle","suite.sequential.only.todo","suite.sequential.concurrent.skip","suite.sequential.concurrent.only","suite.sequential.concurrent.shuffle","suite.sequential.concurrent.todo","suite.sequential.shuffle.skip","suite.sequential.shuffle.only","suite.sequential.shuffle.concurrent","suite.sequential.shuffle.todo","suite.sequential.todo.skip","suite.sequential.todo.only","suite.sequential.todo.concurrent","suite.sequential.todo.shuffle","suite.shuffle.skip.only","suite.shuffle.skip.concurrent","suite.shuffle.skip.sequential","suite.shuffle.skip.todo","suite.shuffle.only.skip","suite.shuffle.only.concurrent","suite.shuffle.only.sequential","suite.shuffle.only.todo","suite.shuffle.concurrent.skip","suite.shuffle.concurrent.only","suite.shuffle.concurrent.sequential","suite.shuffle.concurrent.todo","suite.shuffle.sequential.skip","suite.shuffle.sequential.only","suite.shuffle.sequential.concurrent","suite.shuffle.sequential.todo","suite.shuffle.todo.skip","suite.shuffle.todo.only","suite.shuffle.todo.concurrent","suite.shuffle.todo.sequential","suite.todo.skip.only","suite.todo.skip.concurrent","suite.todo.skip.sequential","suite.todo.skip.shuffle","suite.todo.only.skip","suite.todo.only.concurrent","suite.todo.only.sequential","suite.todo.only.shuffle","suite.todo.concurrent.skip","suite.todo.concurrent.only","suite.todo.concurrent.sequential","suite.todo.concurrent.shuffle","suite.todo.sequential.skip","suite.todo.sequential.only","suite.todo.sequential.concurrent","suite.todo.sequential.shuffle","suite.todo.shuffle.skip","suite.todo.shuffle.only","suite.todo.shuffle.concurrent","suite.todo.shuffle.sequential","suite.skipIf.skip.only","suite.skipIf.skip.concurrent","suite.skipIf.skip.sequential","suite.skipIf.skip.shuffle","suite.skipIf.skip.todo","suite.skipIf.only.skip","suite.skipIf.only.concurrent","suite.skipIf.only.sequential","suite.skipIf.only.shuffle","suite.skipIf.only.todo","suite.skipIf.concurrent.skip","suite.skipIf.concurrent.only","suite.skipIf.concurrent.sequential","suite.skipIf.concurrent.shuffle","suite.skipIf.concurrent.todo","suite.skipIf.sequential.skip","suite.skipIf.sequential.only","suite.skipIf.sequential.concurrent","suite.skipIf.sequential.shuffle","suite.skipIf.sequential.todo","suite.skipIf.shuffle.skip","suite.skipIf.shuffle.only","suite.skipIf.shuffle.concurrent","suite.skipIf.shuffle.sequential","suite.skipIf.shuffle.todo","suite.skipIf.todo.skip","suite.skipIf.todo.only","suite.skipIf.todo.concurrent","suite.skipIf.todo.sequential","suite.skipIf.todo.shuffle","suite.runIf.skip.only","suite.runIf.skip.concurrent","suite.runIf.skip.sequential","suite.runIf.skip.shuffle","suite.runIf.skip.todo","suite.runIf.only.skip","suite.runIf.only.concurrent","suite.runIf.only.sequential","suite.runIf.only.shuffle","suite.runIf.only.todo","suite.runIf.concurrent.skip","suite.runIf.concurrent.only","suite.runIf.concurrent.sequential","suite.runIf.concurrent.shuffle","suite.runIf.concurrent.todo","suite.runIf.sequential.skip","suite.runIf.sequential.only","suite.runIf.sequential.concurrent","suite.runIf.sequential.shuffle","suite.runIf.sequential.todo","suite.runIf.shuffle.skip","suite.runIf.shuffle.only","suite.runIf.shuffle.concurrent","suite.runIf.shuffle.sequential","suite.runIf.shuffle.todo","suite.runIf.todo.skip","suite.runIf.todo.only","suite.runIf.todo.concurrent","suite.runIf.todo.sequential","suite.runIf.todo.shuffle","suite.skip.only.each","suite.skip.concurrent.each","suite.skip.sequential.each","suite.skip.shuffle.each","suite.skip.todo.each","suite.only.skip.each","suite.only.concurrent.each","suite.only.sequential.each","suite.only.shuffle.each","suite.only.todo.each","suite.concurrent.skip.each","suite.concurrent.only.each","suite.concurrent.sequential.each","suite.concurrent.shuffle.each","suite.concurrent.todo.each","suite.sequential.skip.each","suite.sequential.only.each","suite.sequential.concurrent.each","suite.sequential.shuffle.each","suite.sequential.todo.each","suite.shuffle.skip.each","suite.shuffle.only.each","suite.shuffle.concurrent.each","suite.shuffle.sequential.each","suite.shuffle.todo.each","suite.todo.skip.each","suite.todo.only.each","suite.todo.concurrent.each","suite.todo.sequential.each","suite.todo.shuffle.each","suite.skipIf.skip.each","suite.skipIf.only.each","suite.skipIf.concurrent.each","suite.skipIf.sequential.each","suite.skipIf.shuffle.each","suite.skipIf.todo.each","suite.runIf.skip.each","suite.runIf.only.each","suite.runIf.concurrent.each","suite.runIf.sequential.each","suite.runIf.shuffle.each","suite.runIf.todo.each","xtest","xtest.each","xit","xit.each","fit","xdescribe","xdescribe.each","fdescribe"]);function getScope(e,b){return e.sourceCode.getScope?e.sourceCode.getScope(b):e.getScope()}function getModuleScope(e,b){let d=getScope(e,b);for(;d;){if(d.type==="module")return d;d=d.upper}return d}const isTypeOfVitestFnCall=(e,b,d)=>{const Y=parseVitestFnCall(e,b);return Y!==null&&d.includes(Y.type)},parseVitestFnCall=(e,b)=>{const d=parseVitestFnCallWithReason(e,b);return typeof d=="string"?null:d},m$6=new WeakMap,parseVitestFnCallWithReason=(e,b)=>{let d=m$6.get(e);return d||(d=M$3(e,b),m$6.set(e,d),d)},w$2=e=>e==="expect"?"expect":e==="expectTypeOf"?"expectTypeOf":e==="vi"?"vi":e==="vitest"?"vitest":DescribeAlias.hasOwnProperty(e)?"describe":TestCaseName.hasOwnProperty(e)?"test":HookName.hasOwnProperty(e)?"hook":"unknown",A$4=e=>{const b=[];for(const d of e){if(d.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&d.parent.parent?.type===utils.AST_NODE_TYPES.CallExpression)return{matcher:d,args:d.parent.parent.arguments,modifiers:b};const Y=getAccessorValue(d);if(b.length===0){if(!ModifierName.hasOwnProperty(Y))return"modifier-unknown"}else if(b.length===1){if(Y!==ModifierName.not&&Y!=ModifierName.have)return"modifier-unknown";const q=getAccessorValue(b[0]);if(q!==ModifierName.resolves&&q!==ModifierName.rejects&&q!==ModifierName.to)return"modifier-unknown"}else return"modifier-unknown";b.push(d)}return"matcher-not-found"},P$2=(e,b)=>{const d=A$4(e.members);return typeof d=="string"?d:{...e,type:b,...d}},findTopMostCallExpression=e=>{let b=e,{parent:d}=e;for(;d;){if(d.type===utils.AST_NODE_TYPES.CallExpression){b=d,d=d.parent;continue}if(d.type!==utils.AST_NODE_TYPES.MemberExpression)break;d=d.parent}return b},M$3=(e,b)=>{const d=getNodeChain(e);if(!d?.length)return null;const[Y,...q]=d,$=getAccessorValue(d[d.length-1]);if($==="each"&&e.callee.type!==utils.AST_NODE_TYPES.CallExpression&&e.callee.type!==utils.AST_NODE_TYPES.TaggedTemplateExpression||e.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression&&$!=="each")return null;const F=v$1(b,e,getAccessorValue(Y));if(!F)return null;const V=F.original??F.local,G=[V,...q.map(getAccessorValue)];if(F.type!=="testContext"&&V!=="vi"&&V!=="vitest"&&V!=="expect"&&V!=="expectTypeOf"&&!ValidVitestFnCallChains.has(G.join(".")))return null;const X={name:V,head:{...F,node:Y},members:q},z=w$2(V);if(z==="expect"||z==="expectTypeOf"){const J=P$2(X,z);return typeof J=="string"&&findTopMostCallExpression(e)!==e?null:J==="matcher-not-found"&&e.parent?.type===utils.AST_NODE_TYPES.MemberExpression?"matcher-not-called":J}return d.slice(0,d.length-1).some(J=>J.parent?.type!==utils.AST_NODE_TYPES.MemberExpression)||e.parent?.type===utils.AST_NODE_TYPES.CallExpression||e.parent?.type===utils.AST_NODE_TYPES.MemberExpression?null:{...X,type:z}},k$2=(e,b)=>e&&b?[...e,...b]:null;function getNodeChain(e){if(isSupportedAccessor(e))return[e];switch(e.type){case utils.AST_NODE_TYPES.TaggedTemplateExpression:return getNodeChain(e.tag);case utils.AST_NODE_TYPES.MemberExpression:return k$2(getNodeChain(e.object),getNodeChain(e.property));case utils.AST_NODE_TYPES.CallExpression:return getNodeChain(e.callee)}return null}const v$1=(e,b,d)=>{const Y=getScope(e,b),q=resolveScope(Y,d);return q==="local"?null:q==="testContext"?{local:d,original:null,type:"testContext"}:q?q.source==="vitest"?{original:q.imported,local:q.local,type:"import"}:null:{original:N$6(d,e),local:d,type:"global"}},N$6=(e,b)=>{const d=b.settings.vitest?.globalAliases??{},Y=Object.entries(d).find(([q,$])=>$.includes(e));return Y?Y[0]:null},I$2=({parent:e})=>e?.type===utils.AST_NODE_TYPES.CallExpression&&e.callee.type===utils.AST_NODE_TYPES.Identifier&&TestCaseName.hasOwnProperty(e.callee.name),resolveScope=(e,b)=>{let d=e;for(;d!==null;){const Y=d.set.get(b);if(Y&&Y.defs.length>0){const q=Y.defs[Y.defs.length-1],$=isFunction(q.node)?q.node.params.find(G=>G.type===utils.AST_NODE_TYPES.ObjectPattern):void 0;if($){const G=$.properties.find(X=>X.type===utils.AST_NODE_TYPES.Property);if((G?.key.type===utils.AST_NODE_TYPES.Identifier?G.key:void 0)?.name===b)return"testContext"}if(q.node.type===utils.AST_NODE_TYPES.VariableDeclarator&&q.node.id.type===utils.AST_NODE_TYPES.Identifier&&TestCaseName.hasOwnProperty(q.node.id.name)&&q.node.init?.type===utils.AST_NODE_TYPES.CallExpression&&q.node.init.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isIdentifier(q.node.init.callee.property,"extend"))return"testContext";const F=isFunction(q.node)?q.node.params.find(G=>G.type===utils.AST_NODE_TYPES.Identifier):void 0;if(F&&I$2(F.parent))return"testContext";const V=D$1(q);return V?.local===b?V:"local"}d=d.upper}return null},O$3=e=>e.type===utils.AST_NODE_TYPES.AwaitExpression?e.argument.type===utils.AST_NODE_TYPES.ImportExpression?e.argument.source:null:e.type===utils.AST_NODE_TYPES.CallExpression&&isIdentifier(e.callee,"require")?e.arguments[0]??null:null,R=e=>e.parent.type===utils.AST_NODE_TYPES.TSImportEqualsDeclaration||e.node.type!==utils.AST_NODE_TYPES.ImportSpecifier||e.node.imported.type!=utils.AST_NODE_TYPES.Identifier||e.parent.importKind==="type"?null:{source:e.parent.source.value,imported:e.node.imported.name,local:e.node.local.name},D$1=e=>e.type==="Variable"?L$2(e):e.type==="ImportBinding"?R(e):null,L$2=e=>{if(!e.node.init)return null;const b=O$3(e.node.init);return!b||!isStringNode(b)||e.name.parent?.type!==utils.AST_NODE_TYPES.Property||!isSupportedAccessor(e.name.parent.key)?null:{source:getStringValue(b),imported:getAccessorValue(e.name.parent.key),local:e.name.name}},getTestCallExpressionsFromDeclaredVariables=(e,b)=>e.reduce((d,{references:Y})=>d.concat(Y.map(({identifier:q})=>q.parent).filter(q=>q?.type===utils.AST_NODE_TYPES.CallExpression&&isTypeOfVitestFnCall(q,b,["test"]))),[]),getFirstMatcherArg=e=>{const[b]=e.args;return b.type===utils.AST_NODE_TYPES.SpreadElement?b:followTypeAssertionChain$1(b)},K=e=>e.type===utils.AST_NODE_TYPES.TSAsExpression||e.type===utils.AST_NODE_TYPES.TSTypeAssertion,followTypeAssertionChain$1=e=>K(e)?followTypeAssertionChain$1(e.expression):e,RULE_NAME$1a="prefer-lowercase-title",E$3=e=>e.arguments[0]&&isStringNode(e.arguments[0]),x$4=e=>{const b=[];return e.includes(DescribeAlias.describe)&&b.push(...Object.keys(DescribeAlias)),e.includes(TestCaseName.test)&&b.push(...Object.keys(TestCaseName).filter(d=>d.endsWith(TestCaseName.test))),e.includes(TestCaseName.it)&&b.push(...Object.keys(TestCaseName).filter(d=>d.endsWith(TestCaseName.it))),b},xe=createEslintRule({name:RULE_NAME$1a,meta:{type:"problem",docs:{description:"enforce lowercase titles",recommended:!1},fixable:"code",messages:{lowerCaseTitle:"`{{ method }}`s should begin with lowercase",fullyLowerCaseTitle:"`{{ method }}`s should be lowercase"},schema:[{type:"object",properties:{ignore:{type:"array",items:{type:"string",enum:[DescribeAlias.describe,TestCaseName.test,TestCaseName.it]}},allowedPrefixes:{type:"array",items:{type:"string"},additionalItems:!1},ignoreTopLevelDescribe:{type:"boolean",default:!1},lowercaseFirstCharacterOnly:{type:"boolean",default:!0}},additionalProperties:!1}]},defaultOptions:[{ignore:[],allowedPrefixes:[],ignoreTopLevelDescribe:!1,lowercaseFirstCharacterOnly:!0}],create:(e,[{ignore:b=[],allowedPrefixes:d=[],ignoreTopLevelDescribe:Y=!1,lowercaseFirstCharacterOnly:q=!1}])=>{const $=x$4(b);let F=0;return{CallExpression(V){const G=parseVitestFnCall(V,e);if(!G||!E$3)return;if(G?.type==="describe"){if(F++,Y&&F===1)return}else if(G?.type!=="test")return;const[X]=V.arguments,z=getStringValue(X);if(typeof z!="string"||d.some(te=>z.startsWith(te)))return;const J=z.charAt(0);$.includes(G.name)||q&&(!J||J===J.toLowerCase())||!q&&z===z.toLowerCase()||e.report({messageId:q?"lowerCaseTitle":"fullyLowerCaseTitle",node:V.arguments[0],data:{method:G.name},fix:te=>{const Q=getStringValue(X),se=[X.range[0]+1,X.range[1]-1],Z=q?Q.substring(0,1).toLowerCase()+Q.substring(1):Q.toLowerCase();return[te.replaceTextRange(se,Z)]}})},"CallExpression:exit"(V){isTypeOfVitestFnCall(V,e,["describe"])&&F--}}}}),RULE_NAME$19="max-nested-describe",Ce=createEslintRule({name:RULE_NAME$19,meta:{type:"problem",docs:{description:"require describe block to be less than set max value or default value",recommended:!1},schema:[{type:"object",properties:{max:{type:"number"}},additionalProperties:!1}],messages:{maxNestedDescribe:"Nested describe block should be less than set max value"}},defaultOptions:[{max:5}],create(e,[{max:b}]){const d=[];function Y($){$.parent?.type==="CallExpression"&&($.parent.callee.type!=="Identifier"||$.parent.callee.name!=="describe"||(d.push(0),d.length>b&&e.report({node:$.parent,messageId:"maxNestedDescribe"})))}function q($){$.parent?.type==="CallExpression"&&($.parent.callee.type!=="Identifier"||$.parent.callee.name!=="describe"||d.pop())}return{FunctionExpression:Y,"FunctionExpression:exit":q,ArrowFunctionExpression:Y,"ArrowFunctionExpression:exit":q}}}),RULE_NAME$18="no-identical-title",c$6=()=>({describeTitles:[],testTitles:[]}),ve=createEslintRule({name:RULE_NAME$18,meta:{type:"problem",docs:{description:"disallow identical titles",recommended:!1},fixable:"code",schema:[],messages:{multipleTestTitle:"Test is used multiple times in the same describe(suite) block",multipleDescribeTitle:"Describe is used multiple times in the same describe(suite) block"}},defaultOptions:[],create(e){const b=[c$6()];return{CallExpression(d){const Y=b[b.length-1],q=parseVitestFnCall(d,e);if(!q||((q.name==="describe"||q.name==="suite")&&b.push(c$6()),q.members.find(V=>isSupportedAccessor(V,"each"))))return;const[$]=d.arguments;if(!$||!isStringNode($))return;const F=getStringValue($);q.type==="test"&&(Y?.testTitles.includes(F)&&e.report({node:d,messageId:"multipleTestTitle"}),Y?.testTitles.push(F)),q.type==="describe"&&(Y?.describeTitles.includes(F)&&e.report({node:d,messageId:"multipleDescribeTitle"}),Y?.describeTitles.push(F))},"CallExpression:exit"(d){isTypeOfVitestFnCall(d,e,["describe"])&&b.pop()}}}}),RULE_NAME$17="no-focused-tests",n$3=e=>e.type==="Identifier"&&["it","test","describe"].includes(e.name),a$6=e=>e.type==="Identifier"&&e.name==="only",Be=createEslintRule({name:RULE_NAME$17,meta:{type:"problem",docs:{description:"disallow focused tests",recommended:!1},fixable:"code",schema:[{type:"object",properties:{fixable:{type:"boolean",default:!0}},additionalProperties:!1}],messages:{noFocusedTests:"Focused tests are not allowed"}},defaultOptions:[{fixable:!0}],create:(e,b)=>{const d=b[0].fixable;return{ExpressionStatement(Y){if(Y.expression.type==="CallExpression"){const{callee:q}=Y.expression;if(q.type==="MemberExpression"&&n$3(q.object)&&a$6(q.property)&&e.report({node:q.property,messageId:"noFocusedTests",fix:$=>d?$.removeRange([q.property.range[0]-1,q.property.range[1]]):null}),q.type==="TaggedTemplateExpression"){const $=q.tag.type==="MemberExpression"?q.tag.object:null;if(!$)return;$.type==="MemberExpression"&&n$3($.object)&&a$6($.property)&&e.report({node:$.property,messageId:"noFocusedTests",fix:F=>d?F.removeRange([$.property.range[0]-1,$.property.range[1]]):null})}}},CallExpression(Y){if(Y.callee.type==="CallExpression"){const{callee:q}=Y.callee;if(q.type==="MemberExpression"&&q.object.type==="MemberExpression"&&n$3(q.object.object)&&a$6(q.object.property)&&q.property.type==="Identifier"&&q.property.name==="each"){const $=q.object.property;e.report({node:q.object.property,messageId:"noFocusedTests",fix:F=>d?F.removeRange([$.range[0]-1,$.range[1]]):null})}}}}}}),RULE_NAME$16="no-conditional-tests",Ie=createEslintRule({name:RULE_NAME$16,meta:{type:"problem",docs:{description:"disallow conditional tests",recommended:!1},schema:[],messages:{noConditionalTests:"Avoid using if conditions in a test"}},defaultOptions:[],create(e){return{Identifier:function(b){["test","it","describe"].includes(b.name)&&b.parent?.parent?.parent?.parent?.type==="IfStatement"&&e.report({node:b,messageId:"noConditionalTests"})}}}}),i$2={typecheck:!1};function parsePluginSettings(e){const b=typeof e.vitest!="object"||e.vitest===null?{}:e.vitest;return{...i$2,...b}}const RULE_NAME$15="expect-expect",ye=createEslintRule({name:RULE_NAME$15,meta:{type:"suggestion",docs:{description:"enforce having expectation in test body",recommended:!1},schema:[{type:"object",properties:{assertFunctionNames:{type:"array",items:{type:"string"}},additionalTestBlockFunctions:{type:"array",items:{type:"string"}}},additionalProperties:!1}],messages:{noAssertions:"Test has no assertions"}},defaultOptions:[{assertFunctionNames:["expect","assert"],additionalTestBlockFunctions:[]}],create(e,[{assertFunctionNames:b=["expect"],additionalTestBlockFunctions:d=[]}]){const Y=[];parsePluginSettings(e.settings).typecheck&&b.push("expectTypeOf","assertType");const q=b.map(x$3);function $(F){for(const V of F){const G=V.type===utils.AST_NODE_TYPES.CallExpression?Y.indexOf(V):-1;if(V.type===utils.AST_NODE_TYPES.FunctionDeclaration){const X=e.sourceCode.getDeclaredVariables(V),z=getTestCallExpressionsFromDeclaredVariables(X,e);$(z)}if(G!==-1){Y.splice(G,1);break}}}return{CallExpression(F){if(F.callee.type===utils.AST_NODE_TYPES.Identifier&&F.callee.name==="bench"||F?.callee?.type===utils.AST_NODE_TYPES.MemberExpression&&F.callee.property.type===utils.AST_NODE_TYPES.Identifier&&F.callee.property.name==="extend"||F?.callee?.type===utils.AST_NODE_TYPES.MemberExpression&&F.callee.property.type===utils.AST_NODE_TYPES.Identifier&&F.callee.property.name==="skip")return;const V=getNodeName(F)??"";if(isTypeOfVitestFnCall(F,e,["test"])||d.includes(V)){if(F.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(F.callee.property,"todo"))return;Y.push(F)}else q.some(G=>G.test(V))&&$(e.sourceCode.getAncestors(F))},"Program:exit"(){Y.forEach(F=>{e.report({node:F.callee,messageId:"noAssertions"})})}}}});function x$3(e){const b=e.split(".").map(d=>d==="**"?"[_a-z\\d\\.]*":d.replace(/\*/gu,"[a-z\\d]*"));return new RegExp(`^${b.join("\\.")}(\\.|$)`,"ui")}const RULE_NAME$14="hoisted-apis-on-top",c$5=["mock","hoisted","unmock"],Oe=createEslintRule({name:RULE_NAME$14,meta:{hasSuggestions:!0,type:"suggestion",docs:{description:"enforce hoisted APIs to be on top of the file"},messages:{hoistedApisOnTop:"Hoisted API is used in a runtime location in this file, but it is actually executed before this file is loaded.",suggestMoveHoistedApiToTop:"Move this hoisted API to the top of the file to better reflect its behavior.",suggestReplaceMockWithDoMock:"Replace 'vi.mock()' with 'vi.doMock()', which is not hoisted."},schema:[]},defaultOptions:[],create(e){let b=null;const d=[];return{ImportDeclaration(Y){Y.parent.type===utils.AST_NODE_TYPES.Program&&(b=Y.range[1])},CallExpression(Y){if(Y.callee.type!==utils.AST_NODE_TYPES.MemberExpression)return;const{object:q,property:$}=Y.callee;if(q.type!==utils.AST_NODE_TYPES.Identifier||q.name!=="vi"||$.type!==utils.AST_NODE_TYPES.Identifier)return;const F=$.name;if(c$5.includes(F)){if(F==="hoisted"){let V=Y.parent;if(V?.type===utils.AST_NODE_TYPES.AwaitExpression&&(V=V.parent),V?.type===utils.AST_NODE_TYPES.VariableDeclarator&&(V=V.parent),(V?.type===utils.AST_NODE_TYPES.ExpressionStatement||V?.type===utils.AST_NODE_TYPES.VariableDeclaration)&&V.parent?.type===utils.AST_NODE_TYPES.Program)return}else if(Y.parent?.type===utils.AST_NODE_TYPES.ExpressionStatement&&Y.parent.parent?.type===utils.AST_NODE_TYPES.Program)return;d.push(Y)}},"Program:exit"(){for(const Y of d){const q=[];q.push({messageId:"suggestMoveHoistedApiToTop",*fix(F){Y.parent.type===utils.AST_NODE_TYPES.ExpressionStatement?yield F.remove(Y):yield F.replaceText(Y,"undefined"),b!=null?yield F.insertTextAfterRange([b,b],`
`+e.sourceCode.getText(Y)+";"):yield F.insertTextAfterRange([0,0],e.sourceCode.getText(Y)+`;
`)}});const $=Y.callee.property;$.name==="mock"&&q.push({messageId:"suggestReplaceMockWithDoMock",fix(F){return F.replaceText($,"doMock")}}),e.report({node:Y,messageId:"hoistedApisOnTop",suggest:q})}}}}}),RULE_NAME$13="consistent-test-it",h$3=(e,b,d)=>Y=>[Y.replaceText(e.type===utils.AST_NODE_TYPES.MemberExpression?e.object:e,S$5(b,d))];function S$5(e,b){return e===TestCaseName.fit?"test.only":e.startsWith("f")||e.startsWith("x")?e.charAt(0)+b:b}function T$3(e){return e===TestCaseName.test?TestCaseName.it:TestCaseName.test}const Se=createEslintRule({name:RULE_NAME$13,meta:{type:"suggestion",fixable:"code",docs:{description:"enforce using test or it but not both",recommended:!1},messages:{consistentMethod:"Prefer using {{ testFnKeyWork }} instead of {{ oppositeTestKeyword }}",consistentMethodWithinDescribe:"Prefer using {{ testKeywordWithinDescribe }} instead of {{ oppositeTestKeyword }} within describe"},schema:[{type:"object",properties:{fn:{type:"string",enum:[TestCaseName.test,TestCaseName.it]},withinDescribe:{type:"string",enum:[TestCaseName.test,TestCaseName.it]}},additionalProperties:!1}]},defaultOptions:[{}],create(e,b){const{fn:d,withinDescribe:Y}=b[0],q=d||TestCaseName.test,$=Y||d||TestCaseName.it,F=q===$?q:void 0;let V=0;return{ImportDeclaration(G){if(F==null||G.source.type!=="Literal"||G.source.value!=="vitest")return;const X=T$3(F);for(const z of G.specifiers)z.type==="ImportSpecifier"&&z.imported.type==="Identifier"&&z.local.name===z.imported.name&&z.local.name===X&&e.report({node:z,data:{testFnKeyWork:q,oppositeTestKeyword:X},messageId:"consistentMethod",fix:J=>{const te=G.specifiers.filter(Q=>Q.local.name!==X);if(te.length>0){const Q=te.map(Z=>Z.local.name).join(", "),se=G.specifiers.at(-1)?.range;return se?J.replaceTextRange([G.specifiers[0].range[0],se[1]],Q):null}return J.replaceText(z.local,F)}})},CallExpression(G){if(G.callee.type===utils.AST_NODE_TYPES.Identifier&&G.callee.name==="bench")return;const X=parseVitestFnCall(G,e);if(!X)return;if(X.type==="describe"){V++;return}const z=G.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression?G.callee.tag:G.callee.type===utils.AST_NODE_TYPES.CallExpression?G.callee.callee:G.callee;if(X.type==="test"&&V===0&&!X.name.endsWith(q)){const J=T$3(q);e.report({node:G.callee,data:{testFnKeyWork:q,oppositeTestKeyword:J},messageId:"consistentMethod",fix:h$3(z,X.name,q)})}else if(X.type==="test"&&V>0&&!X.name.endsWith($)){const J=T$3($);e.report({messageId:"consistentMethodWithinDescribe",node:G.callee,data:{testKeywordWithinDescribe:$,oppositeTestKeyword:J},fix:h$3(z,X.name,$)})}},"CallExpression:exit"(G){isTypeOfVitestFnCall(G,e,["describe"])&&V--}}}}),RULE_NAME$12="consistent-vitest-vi",g$3=e=>e===UtilName.vi?UtilName.vitest:UtilName.vi,De=createEslintRule({name:RULE_NAME$12,meta:{type:"suggestion",fixable:"code",docs:{description:"enforce using vitest or vi but not both",recommended:!1},messages:{consistentUtil:"Prefer using {{ utilKeyword }} instead of {{ oppositeUtilKeyword }}"},schema:[{type:"object",properties:{fn:{type:"string",enum:[UtilName.vi,UtilName.vitest],default:UtilName.vi}},additionalProperties:!1}]},defaultOptions:[{fn:UtilName.vi}],create(e,b){const d=b[0].fn,Y=g$3(d);return{ImportDeclaration(q){if(!(q.source.type!==utils.AST_NODE_TYPES.Literal||q.source.value!=="vitest"))for(const $ of q.specifiers)$.type===utils.AST_NODE_TYPES.ImportSpecifier&&$.imported.type===utils.AST_NODE_TYPES.Identifier&&$.local.name===$.imported.name&&$.imported.name===Y&&e.report({node:$,messageId:"consistentUtil",data:{utilKeyword:d,oppositeUtilKeyword:Y},fix:F=>{const V=q.specifiers.filter(G=>G.local.name!==Y);if(V.length>0){const G=V.map(z=>z.local.name).join(", "),X=q.specifiers.at(-1)?.range;return X?F.replaceTextRange([q.specifiers[0].range[0],X[1]],G):null}return F.replaceText($.local,d)}})},CallExpression(q){if(parseVitestFnCall(q,e)?.type!==Y)return;const $=q.callee.type===utils.AST_NODE_TYPES.MemberExpression?q.callee.object:q.callee;e.report({node:$,data:{utilKeyword:d,oppositeUtilKeyword:Y},messageId:"consistentUtil",fix:F=>F.replaceText($,d)})}}}}),RULE_NAME$11="prefer-to-be",E$2=e=>e.type===utils.AST_NODE_TYPES.Literal&&e.value===null,N$5=e=>E$2(getFirstMatcherArg(e)),c$4=(e,b)=>isIdentifier(getFirstMatcherArg(e),b),h$2=e=>Math.floor(e)!==Math.ceil(e),y$3=e=>{let b=getFirstMatcherArg(e);return b.type===utils.AST_NODE_TYPES.Literal&&typeof b.value=="number"&&h$2(b.value)?!1:(b.type===utils.AST_NODE_TYPES.UnaryExpression&&b.operator==="-"&&(b=b.argument),b.type===utils.AST_NODE_TYPES.Literal?!("regex"in b):b.type===utils.AST_NODE_TYPES.TemplateLiteral)},o$2=(e,b,d,Y,q)=>{e.report({messageId:`useToBe${b}`,fix($){const F=[replaceAccessorFixer($,d.matcher,`toBe${b}`)];return d.args?.length&&b!==""&&F.push(removeExtraArgumentsFixer($,e,Y,0)),q&&F.push($.removeRange([q.range[0]-1,q.range[1]])),F},node:d.matcher})},He=createEslintRule({name:RULE_NAME$11,meta:{type:"suggestion",docs:{description:"enforce using toBe()",recommended:!1},schema:[],fixable:"code",messages:{useToBe:"Use `toBe` instead",useToBeUndefined:"Use `toBeUndefined()` instead",useToBeDefined:"Use `toBeDefined()` instead",useToBeNull:"Use `toBeNull()` instead",useToBeNaN:"Use `toBeNaN()` instead"}},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const Y=getAccessorValue(d.matcher),q=d.modifiers.find($=>getAccessorValue($)==="not");if(q&&["toBeUndefined","toBeDefined"].includes(Y)){o$2(e,Y==="toBeDefined"?"Undefined":"Defined",d,b,q);return}if(!(!EqualityMatcher.hasOwnProperty(Y)||d.args.length===0)){if(N$5(d)){o$2(e,"Null",d,b);return}if(c$4(d,"undefined")){o$2(e,q?"Defined":"Undefined",d,b);return}if(c$4(d,"NaN")){o$2(e,"NaN",d,b);return}y$3(d)&&Y!==EqualityMatcher.toBe&&o$2(e,"",d,b)}}}}}),RULE_NAME$10="no-hooks",qe=createEslintRule({name:RULE_NAME$10,meta:{type:"suggestion",docs:{description:"disallow setup and teardown hooks",recommended:!1},schema:[{type:"object",properties:{allow:{type:"array",contains:["beforeAll","beforeEach","afterAll","afterEach"]}},additionalProperties:!1}],messages:{unexpectedHook:"Unexpected '{{ hookName }}' hook"}},defaultOptions:[{allow:[]}],create(e,[{allow:b=[]}]){return{CallExpression(d){const Y=parseVitestFnCall(d,e);Y?.type==="hook"&&!b.includes(Y.name)&&e.report({node:d,messageId:"unexpectedHook",data:{hookName:Y.name}})}}}}),RULE_NAME$$="no-restricted-vi-methods",Fe=createEslintRule({name:RULE_NAME$$,meta:{type:"suggestion",docs:{description:"disallow specific `vi.` methods",recommended:!1},schema:[{type:"object",additionalProperties:{type:["string","null"]}}],messages:{restrictedViMethod:"Use of `{{ restriction }}` is disallowed",restrictedViMethodWithMessage:"{{ message }}"}},defaultOptions:[{}],create(e,[b]){return{CallExpression(d){const Y=parseVitestFnCall(d,e);if(Y?.type!=="vi"||Y.members.length===0)return;const q=getAccessorValue(Y.members[0]);if(q in b){const $=b[q];e.report({messageId:$?"restrictedViMethodWithMessage":"restrictedViMethod",data:{message:$,restriction:q},loc:{start:Y.members[0].loc.start,end:Y.members[Y.members.length-1].loc.end}})}}}}}),RULE_NAME$_="consistent-test-filename",n$2=/.*\.test\.[tj]sx?$/,o$1=/.*\.(test|spec)\.[tj]sx?$/,Ve=createEslintRule({name:RULE_NAME$_,meta:{type:"problem",docs:{recommended:!1,requiresTypeChecking:!1,description:"require test file pattern"},messages:{consistentTestFilename:"Use test file name pattern {{ pattern }}"},schema:[{type:"object",additionalProperties:!1,properties:{pattern:{type:"string",format:"regex",default:n$2.source},allTestPattern:{type:"string",format:"regex",default:o$1.source}}}]},defaultOptions:[{pattern:n$2,allTestPattern:o$1}],create:(e,b)=>{const{pattern:d,allTestPattern:Y}=b[0],q=typeof d=="string"?new RegExp(d):d,$=typeof Y=="string"?new RegExp(Y):Y,{filename:F}=e;return $.test(F)?{Program:V=>{q.test(F)||e.report({node:V,messageId:"consistentTestFilename",data:{pattern:q.source}})}}:{}}}),RULE_NAME$Z="max-expects",Pe=createEslintRule({name:RULE_NAME$Z,meta:{docs:{requiresTypeChecking:!1,recommended:!1,description:"enforce a maximum number of expect per test"},messages:{maxExpect:"Too many assertion calls ({{ count }}) - maximum allowed is {{ max }}"},type:"suggestion",schema:[{type:"object",properties:{max:{type:"number"}},additionalProperties:!1}]},defaultOptions:[{max:5}],create(e,[{max:b}]){let d=0;const Y=q=>{(q.parent?.type!==utils.AST_NODE_TYPES.CallExpression||isTypeOfVitestFnCall(q.parent,e,["test"]))&&(d=0)};return{FunctionExpression:Y,"FunctionExpression:exit":Y,ArrowFunctionExpression:Y,"ArrowFunctionExpression:exit":Y,CallExpression(q){const $=parseVitestFnCall(q,e);$?.type!=="expect"||$.head.node.parent?.type===utils.AST_NODE_TYPES.MemberExpression||(d+=1,d>b&&e.report({node:q,messageId:"maxExpect",data:{count:d,max:b}}))}}}}),RULE_NAME$Y="no-alias-methods",Ge=createEslintRule({name:RULE_NAME$Y,meta:{docs:{description:"disallow alias methods",requiresTypeChecking:!1,recommended:!1},messages:{noAliasMethods:"Replace {{ alias }}() with its canonical name {{ canonical }}()"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){const b={toBeCalled:"toHaveBeenCalled",toBeCalledTimes:"toHaveBeenCalledTimes",toBeCalledWith:"toHaveBeenCalledWith",lastCalledWith:"toHaveBeenLastCalledWith",nthCalledWith:"toHaveBeenNthCalledWith",toReturn:"toHaveReturned",toReturnTimes:"toHaveReturnedTimes",toReturnWith:"toHaveReturnedWith",lastReturnedWith:"toHaveLastReturnedWith",nthReturnedWith:"toHaveNthReturnedWith",toThrowError:"toThrow"};return{CallExpression(d){const Y=parseVitestFnCall(d,e);if(Y?.type!=="expect")return;const{matcher:q}=Y,$=getAccessorValue(q);if($ in b){const F=b[$];e.report({messageId:"noAliasMethods",data:{alias:$,canonical:F},node:q,fix:V=>[replaceAccessorFixer(V,q,F)]})}}}}}),RULE_NAME$X="no-commented-out-tests";function n$1(e){return/^\s*[xf]?(test|it|describe)(\.\w+|\[['"]\w+['"]\])?\s*\(/mu.test(e.value)}const je=createEslintRule({name:RULE_NAME$X,meta:{docs:{description:"disallow commented out tests",requiresTypeChecking:!1,recommended:!1},messages:{noCommentedOutTests:"Remove commented out tests - you may want to use `skip` or `only` instead"},schema:[],type:"suggestion"},defaultOptions:[],create(e){const{sourceCode:b}=e;function d(Y){n$1(Y)&&e.report({messageId:"noCommentedOutTests",node:Y})}return{Program(){b.getAllComments().forEach(d)}}}}),RULE_NAME$W="no-conditional-expect",r=e=>e.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(e.callee.property,"catch"),We=createEslintRule({name:RULE_NAME$W,meta:{type:"problem",docs:{description:"disallow conditional expects",requiresTypeChecking:!1,recommended:!1},messages:{noConditionalExpect:"Avoid calling `expect` inside conditional statements"},schema:[]},defaultOptions:[],create(e){let b=0,d=!1,Y=!1;const q=()=>d&&b++,$=()=>d&&b--;return{FunctionDeclaration(F){const V=e.sourceCode.getDeclaredVariables(F);getTestCallExpressionsFromDeclaredVariables(V,e).length>0&&(d=!0)},CallExpression(F){const{type:V}=parseVitestFnCall(F,e)??{};V==="test"&&(d=!0),r(F)&&(Y=!0),d&&V==="expect"&&b>0&&e.report({messageId:"noConditionalExpect",node:F}),Y&&V==="expect"&&e.report({messageId:"noConditionalExpect",node:F})},"CallExpression:exit"(F){isTypeOfVitestFnCall(F,e,["test"])&&(d=!1),r(F)&&(Y=!1)},CatchClause:q,"CatchClause:exit":$,IfStatement:q,"IfStatement:exit":$,SwitchStatement:q,"SwitchStatement:exit":$,ConditionalExpression:q,"ConditionalExpression:exit":$,LogicalExpression:q,"LogicalExpression:exit":$}}}),RULE_NAME$V="no-import-node-test",Ke=createEslintRule({name:RULE_NAME$V,meta:{docs:{description:"disallow importing `node:test`",recommended:!1},type:"suggestion",messages:{noImportNodeTest:"Import from `vitest` instead of `node:test`"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{ImportDeclaration(b){b.source.value==="node:test"&&e.report({messageId:"noImportNodeTest",node:b,fix:d=>d.replaceText(b.source,b.source.raw.replace("node:test","vitest"))})}}}}),VITEST_GLOBALS=new Set(["suite","test","chai","describe","it","expectTypeOf","assertType","expect","assert","vitest","vi","beforeAll","afterAll","beforeEach","afterEach","onTestFailed","onTestFinished"]),isVitestImport=e=>e.source.value==="vitest",isVitestGlobalsImportSpecifier=e=>e.type===utils.AST_NODE_TYPES.ImportSpecifier&&e.imported.type===utils.AST_NODE_TYPES.Identifier&&VITEST_GLOBALS.has(e.imported.name),isVitestGlobalsProperty=e=>e.type===utils.AST_NODE_TYPES.Property&&e.key.type===utils.AST_NODE_TYPES.Identifier&&VITEST_GLOBALS.has(e.key.name),isVitestGlobalsFunction=e=>e.callee.type===utils.AST_NODE_TYPES.Identifier&&VITEST_GLOBALS.has(e.callee.name),isRequireVitestCall=e=>{if(e?.type!==utils.AST_NODE_TYPES.CallExpression||e.callee.type!==utils.AST_NODE_TYPES.Identifier||e.callee.name!=="require")return!1;const b=e.arguments;return b.length===1&&b[0].type===utils.AST_NODE_TYPES.Literal&&b[0].value==="vitest"},isObjectPattern=e=>e.type===utils.AST_NODE_TYPES.ObjectPattern,removeVariableDeclarator=(e,b)=>{const d=b.parent,Y=d.declarations;if(Y.length===1)return e.remove(d);const q=Y.findIndex($=>$.range[0]===b.range[0]&&$.range[1]===b.range[1]);if(q===0){const $=Y[1];return e.removeRange([b.range[0],$.range[0]])}else{const $=Y[q-1];return e.removeRange([$.range[1],b.range[1]])}},removeNodeFromArray=(e,b,d)=>{const Y=b.indexOf(d);if(Y===-1)throw new Error("Target node not found in nodes array");if(Y===0){const q=b[1];return e.removeRange([d.range[0],q.range[0]])}else{const q=b[Y-1];return e.removeRange([q.range[1],d.range[1]])}},RULE_NAME$U="no-importing-vitest-globals",$e=createEslintRule({name:RULE_NAME$U,meta:{type:"suggestion",docs:{description:"disallow importing Vitest globals",recommended:!1},messages:{noImportingVitestGlobals:"Do not import '{{name}}' from 'vitest'. Use globals configuration instead.",noRequiringVitestGlobals:"Do not require '{{name}}' from 'vitest'. Use globals configuration instead."},fixable:"code",schema:[]},defaultOptions:[],create(e){return{ImportDeclaration(b){if(!isVitestImport(b))return;const d=b.specifiers;for(const Y of d)isVitestGlobalsImportSpecifier(Y)&&e.report({node:Y,messageId:"noImportingVitestGlobals",data:{name:Y.imported.name},fix(q){return d.every($=>isVitestGlobalsImportSpecifier($))?q.remove(b):removeNodeFromArray(q,d,Y)}})},VariableDeclarator(b){if(!isRequireVitestCall(b.init)||!isObjectPattern(b.id))return;const d=b.id.properties;for(const Y of d)isVitestGlobalsProperty(Y)&&e.report({node:Y,messageId:"noRequiringVitestGlobals",data:{name:Y.key.name},fix(q){return d.every($=>isVitestGlobalsProperty($))?removeVariableDeclarator(q,b):removeNodeFromArray(q,d,Y)}})}}}}),RULE_NAME$T="prefer-importing-vitest-globals",ze=createEslintRule({name:RULE_NAME$T,meta:{type:"suggestion",docs:{description:"enforce importing Vitest globals",recommended:!1},messages:{preferImportingVitestGlobals:"Import '{{name}}' from 'vitest'"},schema:[],fixable:"code"},defaultOptions:[],create(e){const b=new Set;let d,Y;return{ImportDeclaration(q){if(!isVitestImport(q))return;const $=q.specifiers;for(const F of $)if(isVitestGlobalsImportSpecifier(F)){const V=F.imported.name;b.add(V)}d=q.specifiers},VariableDeclarator(q){if(!isRequireVitestCall(q.init)||!isObjectPattern(q.id))return;const $=q.id.properties;for(const F of $)if(isVitestGlobalsProperty(F)){const V=F.key.name;b.add(V)}Y=$},CallExpression(q){if(!isVitestGlobalsFunction(q))return;const $=q.callee.name;if(b.has($))return;const F=e.sourceCode.getScope(q).set.get($);F&&F.defs.length>0&&F.defs.some(V=>!(V.type==="ImportBinding"||V.type==="Variable"&&V.node.init&&isRequireVitestCall(V.node.init)))||e.report({node:q.callee,messageId:"preferImportingVitestGlobals",data:{name:$},fix(V){const G=e.sourceCode.ast;if(!d)if(Y){const J=Y[Y.length-1];return V.insertTextAfter(J,`, ${$}`)}else return V.insertTextBefore(G.body[0],`import { ${$} } from 'vitest';
`);if(d.find(J=>J.type==="ImportNamespaceSpecifier"))return V.insertTextBefore(G.body[0],`import { ${$} } from 'vitest';
`);const X=d.find(J=>J.type==="ImportDefaultSpecifier");if(X)return V.insertTextAfter(X,`, { ${$} }`);const z=d[d.length-1];return V.insertTextAfter(z,`, ${$}`)}})}}}}),RULE_NAME$S="no-conditional-in-test",Je=createEslintRule({name:RULE_NAME$S,meta:{docs:{description:"disallow conditional tests",requiresTypeChecking:!1,recommended:!1},messages:{noConditionalInTest:"Remove conditional tests"},schema:[],type:"problem"},defaultOptions:[],create(e){return{IfStatement(b){b.parent?.parent?.parent?.type==="CallExpression"&&isTypeOfVitestFnCall(b.parent?.parent?.parent,e,["test","it"])&&e.report({messageId:"noConditionalInTest",node:b})}}}}),RULE_NAME$R="no-disabled-tests",Qe=createEslintRule({name:RULE_NAME$R,meta:{type:"suggestion",docs:{description:"disallow disabled tests",recommended:!1},messages:{missingFunction:"Test is missing function argument",pending:"Call to pending()",pendingSuite:"Call to pending() within test suite",pendingTest:"Call to pending() within test",disabledSuite:"Disabled test suite - if you want to skip a test suite temporarily, use .todo() instead",disabledTest:"Disabled test - if you want to skip a test temporarily, use .todo() instead"},schema:[]},defaultOptions:[],create(e){let b=0,d=0;return{CallExpression(Y){const q=parseVitestFnCall(Y,e);if(!q)return;q.type==="describe"&&b++,q.type==="test"&&(d++,Y.arguments.length<2&&q.members.every(F=>getAccessorValue(F)==="skip")&&e.report({messageId:"missingFunction",node:Y}));const $=q.members.find(F=>getAccessorValue(F)==="skip");(q.name.startsWith("x")||$!==void 0)&&e.report({messageId:q.type==="describe"?"disabledSuite":"disabledTest",node:$??q.head.node})},"CallExpression:exit"(Y){const q=parseVitestFnCall(Y,e);q&&(q.type==="describe"&&b--,q.type==="test"&&d--)},'CallExpression[callee.name="pending"]'(Y){const q=getScope(e,Y);resolveScope(q,"pending")||(d>0?e.report({messageId:"pendingTest",node:Y}):b>0?e.report({messageId:"pendingSuite",node:Y}):e.report({messageId:"pending",node:Y}))}}}}),RULE_NAME$Q="no-done-callback",P$1=(e,b,d)=>{if(b)return e.arguments[1];const Y=parseVitestFnCall(e,d);return Y?.type==="hook"&&e.arguments.length>=1?e.arguments[0]:Y?.type==="test"&&e.arguments.length>=2?e.arguments[1]:null},Xe=createEslintRule({name:RULE_NAME$Q,meta:{type:"suggestion",docs:{description:"disallow using a callback in asynchronous tests and hooks",recommended:!1},deprecated:!0,schema:[],messages:{noDoneCallback:"Return a promise instead of relying on callback parameter",suggestWrappingInPromise:"Wrap in `new Promise({{ callback }} => ...`",useAwaitInsteadOfCallback:"Use `await` instead of callback in async function"},hasSuggestions:!0},defaultOptions:[],create(e){return{CallExpression(b){const d=/\.each$|\.concurrent$/.test(getNodeName(b.callee)??"");if(d&&b.callee.type!==utils.AST_NODE_TYPES.TaggedTemplateExpression||e.sourceCode.getAncestors(b).some(F=>F.type!==utils.AST_NODE_TYPES.CallExpression||!isTypeOfVitestFnCall(F,e,["describe","test"])?!1:F.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(F.callee.property,"concurrent")))return;const Y=P$1(b,d,e),q=Number(d);if(!Y||!isFunction(Y)||Y.params.length!==1+q)return;const $=Y.params[q];if($.type!==utils.AST_NODE_TYPES.Identifier){e.report({node:$,messageId:"noDoneCallback"});return}if(Y.async){e.report({node:$,messageId:"useAwaitInsteadOfCallback"});return}e.report({node:b,messageId:"noDoneCallback",suggest:[{messageId:"suggestWrappingInPromise",data:{callback:$.name},fix(F){const{body:V,params:G}=Y,{sourceCode:X}=e,z=X.getFirstToken(V),J=X.getLastToken(V),[te]=G,Q=G[G.length-1],se=X.getTokenBefore(te);let Z=X.getTokenAfter(Q);if(Z?.value===","&&(Z=X.getTokenAfter(Z)),!z||!J||!se||!Z)throw new Error(`Unexpected null when attempting to fix ${e.filename} - please file an issue at https://github/veritem/eslint-plugin-vitest`);let ee=F.replaceText(te,"()");se.value==="("&&Z.value===")"&&(ee=F.removeRange([se.range[1],Z.range[0]]));let re=`new Promise(${$.name} => `,oe=")",ne=!0;return V.type===utils.AST_NODE_TYPES.BlockStatement&&(re=`return ${re}{`,oe+="}",ne=!1),[ee,ne?F.insertTextBefore(z,re):F.insertTextAfter(z,re),F.insertTextAfter(J,oe)]}}]})}}}}),RULE_NAME$P="no-duplicate-hooks",Ye=createEslintRule({name:RULE_NAME$P,meta:{docs:{recommended:!1,description:"disallow duplicate hooks and teardown hooks",requiresTypeChecking:!1},messages:{noDuplicateHooks:"Duplicate {{ hook }} in describe block"},schema:[],type:"suggestion"},defaultOptions:[],create(e){const b=[{}];return{CallExpression(d){const Y=parseVitestFnCall(d,e);if(Y?.type==="describe"&&b.push({}),Y?.type!=="hook")return;const q=b[b.length-1];q[Y.name]||=0,q[Y.name]+=1,q[Y.name]>1&&e.report({messageId:"noDuplicateHooks",data:{hook:Y.name},node:d})},"CallExpression:exit"(d){isTypeOfVitestFnCall(d,e,["describe"])&&b.pop()}}}}),RULE_NAME$O="no-large-snapshots",m$5=(e,b,{maxSize:d=50,allowedSnapshots:Y={}})=>{const q=b.loc.start.line,$=b.loc.end.line-q;if(!Object.keys(Y).every(node_path.isAbsolute))throw new Error("All paths for allowedSnapshots must be absolute. You can use JS config and `path.resolve`");let F=!1;if(b.type===utils.AST_NODE_TYPES.ExpressionStatement&&"left"in b.expression&&b.expression.left.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(b.expression.left.property)){const V=e.filename,G=Y[V];if(G){const X=getAccessorValue(b.expression.left.property);F=G.some(z=>z instanceof RegExp?z.test(X):X===z)}}!F&&$>d&&e.report({node:b,messageId:d===0?"noSnapShot":"tooLongSnapShot",data:{lineCount:$,lineLimit:d}})},Ze=createEslintRule({name:RULE_NAME$O,meta:{docs:{description:"disallow large snapshots",recommended:!1},messages:{noSnapShot:"`{{ lineCount }}`s should begin with lowercase",tooLongSnapShot:"Expected vitest snapshot to be smaller than {{ lineLimit }} lines but was {{ lineCount }} lines long"},type:"suggestion",schema:[{type:"object",properties:{maxSize:{type:"number"},inlineMaxSize:{type:"number"},allowedSnapshots:{type:"object",additionalProperties:{type:"array"}}},additionalProperties:!1}]},defaultOptions:[{}],create(e,[b]){return e.filename.endsWith(".snap")?{ExpressionStatement(d){m$5(e,d,b)}}:{CallExpression(d){const Y=parseVitestFnCall(d,e);Y?.type==="expect"&&["toMatchInlineSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(getAccessorValue(Y.matcher))&&Y.args.length&&m$5(e,Y.args[0],{...b,maxSize:b.inlineMaxSize??b.maxSize})}}}}),RULE_NAME$N="no-interpolation-in-snapshots",er=createEslintRule({name:RULE_NAME$N,meta:{type:"problem",docs:{description:"disallow string interpolation in snapshots",recommended:!1},fixable:"code",schema:[],messages:{noInterpolationInSnapshots:"Do not use string interpolation in snapshots"}},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);d?.type==="expect"&&["toMatchInlineSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(getAccessorValue(d.matcher))&&d.args.forEach(Y=>{Y.type===utils.AST_NODE_TYPES.TemplateLiteral&&Y.expressions.length>0&&e.report({messageId:"noInterpolationInSnapshots",node:Y})})}}}}),t="__mocks__",p$1=e=>e.split(node_path.posix.sep).includes(t),s=e=>isStringNode(e)&&p$1(getStringValue(e)),RULE_NAME$M="no-mocks-import",rr=createEslintRule({name:RULE_NAME$M,meta:{type:"problem",docs:{description:"disallow importing from __mocks__ directory",recommended:!1},messages:{noMocksImport:`Mocks should not be manually imported from a ${t} directory. Instead use \`vi.mock\` and import from the original module path`},schema:[]},defaultOptions:[],create(e){return{ImportDeclaration(b){s(b.source)&&e.report({node:b,messageId:"noMocksImport"})},'CallExpression[callee.name="require"]'(b){const[d]=b.arguments;d&&s(d)&&e.report({node:d,messageId:"noMocksImport"})}}}}),RULE_NAME$L="no-restricted-matchers",l$3=(e,b)=>ModifierName.hasOwnProperty(b)||b.endsWith(".not")?e.startsWith(b):e===b,or=createEslintRule({name:RULE_NAME$L,meta:{docs:{description:"disallow the use of certain matchers",recommended:!1},type:"suggestion",schema:[{type:"object",additionalProperties:{type:["string","null"]}}],messages:{restrictedChain:"use of {{ restriction }} is disallowed",restrictedChainWithMessage:"{{ message }}"}},defaultOptions:[{}],create(e,[b]){return{CallExpression(d){const Y=parseVitestFnCall(d,e);if(Y?.type!=="expect")return;const q=Y.members.map($=>getAccessorValue($)).join(".");for(const[$,F]of Object.entries(b))if(l$3(q,$)){e.report({messageId:F?"restrictedChainWithMessage":"restrictedChain",data:{message:F,restriction:$},loc:{start:Y.members[0].loc.start,end:Y.members[Y.members.length-1].loc.end}});break}}}}}),RULE_NAME$K="no-standalone-expect",a$5=(e,b)=>{const d=e.parent;if(!d)throw new Error("Unexpected block statement. If you feel like this is a bug report https://github.com/veritem/eslint-plugin-vitest/issues/new");if(d.type===utils.AST_NODE_TYPES.FunctionDeclaration)return"function";if(isFunction(d)&&d.parent){const Y=d.parent;if(Y.type===utils.AST_NODE_TYPES.VariableDeclarator)return"function";if(Y.type===utils.AST_NODE_TYPES.CallExpression&&isTypeOfVitestFnCall(Y,b,["describe"]))return"describe"}return null},ar=createEslintRule({name:RULE_NAME$K,meta:{docs:{description:"disallow using `expect` outside of `it` or `test` blocks",recommended:!1},type:"suggestion",messages:{noStandaloneExpect:"Expect must be called inside a test block"},schema:[{type:"object",properties:{additionalTestBlockFunctions:{type:"array",items:{type:"string"}}},additionalProperties:!1}]},defaultOptions:[{additionalTestBlockFunctions:[]}],create(e,[{additionalTestBlockFunctions:b=[]}]){const d=[],Y=q=>b.includes(getNodeName(q)||"");return{CallExpression(q){const $=parseVitestFnCall(q,e);if($?.type==="expect"){if($.head.node.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&$.members.length===1&&!["assertions","hasAssertions"].includes(getAccessorValue($.members[0])))return;const F=d[d.length-1];(!F||F===DescribeAlias.describe)&&e.report({node:q,messageId:"noStandaloneExpect"});return}($?.type==="test"||Y(q))&&d.push("test"),q.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression&&d.push("template")},"CallExpression:exit"(q){const $=d[d.length-1];($==="test"&&(isTypeOfVitestFnCall(q,e,["test"])||Y(q))&&q.callee.type!==utils.AST_NODE_TYPES.MemberExpression||$==="template"&&q.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression)&&d.pop()},BlockStatement(q){const $=a$5(q,e);$&&d.push($)},"BlockStatement:exit"(q){a$5(q,e)&&d.pop()},ArrowFunctionExpression(q){q.parent?.type!==utils.AST_NODE_TYPES.CallExpression&&d.push("arrow")},"ArrowFunctionExpression:exit"(){d[d.length-1]==="arrow"&&d.pop()}}}}),RULE_NAME$J="no-test-prefixes",tr=createEslintRule({name:RULE_NAME$J,meta:{docs:{description:"disallow using the `f` and `x` prefixes in favour of `.only` and `.skip`",recommended:!1},type:"suggestion",messages:{usePreferredName:'Use "{{ preferredNodeName }}" instead'},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="describe"&&d?.type!=="test"||d.name[0]!=="f"&&d.name[0]!=="x")return;const Y=[d.name.slice(1),d.name[0]==="f"?"only":"skip",...d.members.map($=>getAccessorValue($))].join("."),q=b.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression?b.callee.tag:b.callee.type===utils.AST_NODE_TYPES.CallExpression?b.callee.callee:b.callee;e.report({messageId:"usePreferredName",node:b.callee,data:{preferredNodeName:Y},fix:$=>[$.replaceText(q,Y)]})}}}}),RULE_NAME$I="no-test-return-statement",u$3=e=>{const[,b]=e;return b&&isFunction(b)&&b.body.type===utils.AST_NODE_TYPES.BlockStatement?b.body.body:[]},nr=createEslintRule({name:RULE_NAME$I,meta:{type:"problem",docs:{description:"disallow return statements in tests",recommended:!1},schema:[],messages:{noTestReturnStatement:"Return statements are not allowed in tests"}},defaultOptions:[],create(e){return{CallExpression(b){if(!isTypeOfVitestFnCall(b,e,["test"]))return;const d=u$3(b.arguments).find(Y=>Y.type===utils.AST_NODE_TYPES.ReturnStatement);d&&e.report({messageId:"noTestReturnStatement",node:d})},FunctionDeclaration(b){const d=e.sourceCode.getDeclaredVariables(b);if(getTestCallExpressionsFromDeclaredVariables(d,e).length===0)return;const Y=b.body.body.find(q=>q.type===utils.AST_NODE_TYPES.ReturnStatement);Y&&e.report({messageId:"noTestReturnStatement",node:Y})}}}}),RULE_NAME$H="prefer-called-with",sr=createEslintRule({name:RULE_NAME$H,meta:{docs:{description:"enforce using `toBeCalledWith()` or `toHaveBeenCalledWith()`",recommended:!1},messages:{preferCalledWith:"Prefer {{ matcherName }}With(/* expected args */)"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect"||d.modifiers.some($=>getAccessorValue($)==="not"))return;const{matcher:Y}=d,q=getAccessorValue(Y);["toBeCalled","toHaveBeenCalled"].includes(q)&&e.report({data:{matcherName:q},messageId:"preferCalledWith",node:Y,fix:$=>[$.replaceText(Y,`${q}With`)]})}}}}),RULE_NAME$G="valid-title",_$1=e=>["f","x"].includes(e.charAt(0))?e.substring(1):e,S$4=e=>e.type===utils.AST_NODE_TYPES.TemplateLiteral?`\`${e.quasis[0].value.raw}\``:e.raw,N$4={type:"array",items:{type:"string"},minItems:1,maxItems:2,additionalItems:!1},c$3=e=>{const[b,d]=Array.isArray(e)?e:[e];return[new RegExp(b,"u"),d]};function j(e){return!!(e.flags&n__default.TypeFlags.StringLike)}const T$2=e=>{if(typeof e=="string"||Array.isArray(e)){const b=c$3(e);return{describe:b,test:b,it:b}}return{describe:e.describe?c$3(e.describe):null,test:e.test?c$3(e.test):null,it:e.it?c$3(e.it):null}},A$3=e=>isStringNode(e.right)?!0:e.left.type===utils.AST_NODE_TYPES.BinaryExpression?A$3(e.left):isStringNode(e.left),ir=createEslintRule({name:RULE_NAME$G,meta:{docs:{description:"enforce valid titles",recommended:!1},messages:{titleMustBeString:"Test title must be a string, a function or class name",emptyTitle:"{{ functionName }} should not have an empty title",duplicatePrefix:"should not have duplicate prefix",accidentalSpace:"should not have leading or trailing spaces",disallowedWord:'"{{ word }}" is not allowed in test title',mustNotMatch:"{{ functionName }} should not match {{ pattern }}",mustMatch:"{{ functionName }} should match {{ pattern }}",mustNotMatchCustom:"{{ message }}",mustMatchCustom:"{{ message }}"},type:"suggestion",schema:[{type:"object",properties:{ignoreTypeOfDescribeName:{type:"boolean",default:!1},allowArguments:{type:"boolean",default:!1},disallowedWords:{type:"array",items:{type:"string"}}},patternProperties:{[/^must(?:Not)?Match$/u.source]:{oneOf:[{type:"string"},N$4,{type:"object",propertyNames:{type:"string",enum:["describe","test","it"]},additionalProperties:{oneOf:[{type:"string"},N$4]}}]}},additionalProperties:!1}],fixable:"code"},defaultOptions:[{ignoreTypeOfDescribeName:!1,allowArguments:!1,disallowedWords:[]}],create(e,[{ignoreTypeOfDescribeName:b,allowArguments:d,disallowedWords:Y=[],mustNotMatch:q,mustMatch:$}]){const F=new RegExp(`\\b(${Y.join("|")})\\b`,"iu"),V=T$2(q??{}),G=T$2($??{}),X=parsePluginSettings(e.settings);return{CallExpression(z){const J=parseVitestFnCall(z,e);if(J?.type!=="describe"&&J?.type!=="test"&&J?.type!=="it"||J.members&&J.members[0]&&J.members[0].type===utils.AST_NODE_TYPES.Identifier&&J.members[0].name==="extend")return;const te=ae=>{e.report({messageId:"emptyTitle",data:{functionName:J.type==="describe"?DescribeAlias.describe:TestCaseName.test},node:ae})},[Q]=z.arguments,se=X.typecheck?utils.ESLintUtils.getParserServices(e).getTypeAtLocation(Q):null;if(se&&isClassOrFunctionType(se)||!Q||d&&Q.type===utils.AST_NODE_TYPES.Identifier)return;if(!isStringNode(Q)){if(Q.type===utils.AST_NODE_TYPES.BinaryExpression&&A$3(Q)||se&&j(se))return;Q.type!==utils.AST_NODE_TYPES.TemplateLiteral&&!(b&&J.type==="describe")&&e.report({messageId:"titleMustBeString",loc:Q.loc});return}const Z=getStringValue(Q);if(!Z){te(z);return}if(Y.length>0){const ae=F.exec(Z);if(ae){e.report({messageId:"disallowedWord",data:{word:ae[1]},node:Q});return}}Z.trim().length!==Z.length&&e.report({messageId:"accidentalSpace",node:Q,fix:ae=>[ae.replaceTextRange(Q.range,S$4(Q).replace(/^([`'"]) +?/u,"$1").replace(/ +?([`'"])$/u,"$1"))]});const ee=_$1(J.name),[re]=Z.split(" ");re.toLowerCase()===ee&&e.report({messageId:"duplicatePrefix",node:Q,fix:ae=>[ae.replaceTextRange(Q.range,S$4(Q).replace(/^([`'"]).+? /u,"$1"))]});const oe=ee,[ne,ie]=V[oe]??[];if(ne&&ne.test(Z)){e.report({messageId:ie?"mustNotMatchCustom":"mustNotMatch",node:Q,data:{functionName:oe,pattern:ne,message:ie}});return}const[ce,le]=G[oe]??[];ce&&(ce.test(Z)||e.report({messageId:le?"mustMatchCustom":"mustMatch",node:Q,data:{functionName:oe,pattern:ce,message:le}}))}}}}),RULE_NAME$F="valid-expect",h$1=["toReject","toResolve"],D=e=>(e.type===utils.AST_NODE_TYPES.ArrayExpression&&e.parent&&e.parent.type===utils.AST_NODE_TYPES.CallExpression&&(e=e.parent),e.type===utils.AST_NODE_TYPES.CallExpression&&e.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(e.callee.object,"Promise")&&e.parent?e:null),A$2=({start:e,end:b})=>`${e.line}:${e.column}-${b.line}:${b.column}`,O$2=e=>e.parent.type===utils.AST_NODE_TYPES.Property&&e.type===utils.AST_NODE_TYPES.FunctionExpression?e.parent:e;function M$2(e){const b=e.parent?.parent;return b&&b.type===utils.AST_NODE_TYPES.CallExpression&&b.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(b.callee.property)&&["then","catch"].includes(getAccessorValue(b.callee.property))&&b.parent?M$2(b):e}const U=e=>e.parent?.parent&&[utils.AST_NODE_TYPES.CallExpression,utils.AST_NODE_TYPES.ArrayExpression].includes(e.parent.type)?D(e.parent):null,N$3=({parent:e})=>e?isFunction(e)?e:N$3(e):null,w$1=(e,b)=>b&&e.type===utils.AST_NODE_TYPES.ReturnStatement?!0:e.type===utils.AST_NODE_TYPES.ConditionalExpression&&e.parent?w$1(e.parent,b):[utils.AST_NODE_TYPES.ArrowFunctionExpression,utils.AST_NODE_TYPES.AwaitExpression].includes(e.type),mr=createEslintRule({name:RULE_NAME$F,meta:{docs:{description:"enforce valid `expect()` usage",recommended:!1},messages:{tooManyArgs:"Expect takes at most {{ amount}} argument{{ s }}",notEnoughArgs:"Expect requires at least {{ amount }} argument{{ s }}",modifierUnknown:"Expect has an unknown modifier",matcherNotFound:"Expect must have a corresponding matcher call",matcherNotCalled:"Matchers must be called to assert",asyncMustBeAwaited:"Async assertions must be awaited{{ orReturned }}",promisesWithAsyncAssertionsMustBeAwaited:"Promises which return async assertions must be awaited{{ orReturned }}"},type:"suggestion",fixable:"code",schema:[{type:"object",properties:{alwaysAwait:{type:"boolean",default:!1},asyncMatchers:{type:"array",items:{type:"string"}},minArgs:{type:"number",minimum:1},maxArgs:{type:"number",minimum:1}},additionalProperties:!1}]},defaultOptions:[{alwaysAwait:!1,asyncMatchers:h$1,minArgs:1,maxArgs:1}],create:(e,[{alwaysAwait:b,asyncMatchers:d=h$1,minArgs:Y=1,maxArgs:q=1}])=>{const $=new Set,F=[],V=z=>$.add(A$2(z)),G=z=>$.has(A$2(z)),X=z=>{let J=z,{parent:te}=z;for(;te&&te.type===utils.AST_NODE_TYPES.MemberExpression;)J=te,te=te.parent;return J};return{CallExpression(z){const J=parseVitestFnCallWithReason(z,e),te=parsePluginSettings(e.settings);if(typeof J=="string"){const ie=z.parent?.type===utils.AST_NODE_TYPES.MemberExpression?X(z.parent).property:z;if(J==="matcher-not-found"){e.report({messageId:"matcherNotFound",node:ie});return}if(J==="matcher-not-called"&&e.report({messageId:isSupportedAccessor(ie)&&ModifierName.hasOwnProperty(getAccessorValue(ie))?"matcherNotFound":"matcherNotCalled",node:ie}),J==="modifier-unknown"){e.report({messageId:"modifierUnknown",node:ie});return}return}else if(J?.type==="expectTypeOf"&&te.typecheck||J?.type!=="expect"||J.modifiers.some(ie=>ie.type===utils.AST_NODE_TYPES.Identifier&&ie.name=="to"))return;const{parent:Q}=J.head.node;if(Q?.type!==utils.AST_NODE_TYPES.CallExpression)return;if(Q.arguments.length<Y){const ie=getAccessorValue(J.head.node).length,ce={start:{column:Q.loc.start.column+ie,line:Q.loc.start.line},end:{column:Q.loc.start.column+ie+1,line:Q.loc.start.line}};e.report({messageId:"notEnoughArgs",data:{amount:Y,s:Y===1?"":"s"},node:Q,loc:ce})}if(Q.arguments.length>q){if(Q.arguments.length===2){const ae=Q.arguments[1].type===utils.AST_NODE_TYPES.Literal&&typeof Q.arguments[1].value=="string",ue=Q.arguments[1].type===utils.AST_NODE_TYPES.TemplateLiteral;if(ae||ue)return}const{start:ie}=Q.arguments[q].loc,{end:ce}=Q.arguments[Q.arguments.length-1].loc,le={start:ie,end:{column:ce.column+1,line:ce.line}};e.report({messageId:"tooManyArgs",data:{amount:q,s:q===1?"":"s"},node:Q,loc:le})}const{matcher:se}=J,Z=se.parent.parent,ee=J.modifiers.some(ie=>getAccessorValue(ie)!=="not")||d.includes(getAccessorValue(se));if(!Z?.parent||!ee)return;const re=Z.parent.type===utils.AST_NODE_TYPES.ArrayExpression,oe=M$2(Z),ne=U(oe)||oe;ne.parent&&!w$1(ne.parent,!b)&&!G(ne.loc)&&(F.push({messageId:ne===oe?"asyncMustBeAwaited":"promisesWithAsyncAssertionsMustBeAwaited",node:ne}),re&&V(ne.loc))},"Program:exit"(){const z=[];F.forEach(({node:J,messageId:te},Q)=>{const se=b?"":" or returned";e.report({loc:J.loc,data:{orReturned:se},messageId:te,node:J,fix(Z){const ee=N$3(J);if(!ee)return null;const re=z.some(ne=>ne.text==="async ");if(!ee.async&&!re){const ne=O$2(ee);z.push(Z.insertTextBefore(ne,"async "))}const oe=J.parent?.type===utils.AST_NODE_TYPES.ReturnStatement?J.parent:null;if(b&&oe){const ne=e.sourceCode.getText(oe).replace("return","await");z.push(Z.replaceText(oe,ne))}else z.push(Z.insertTextBefore(J,"await "));return Q===F.length-1?z:null}})})}}}}),isBooleanLiteral=e=>e.type===utils.AST_NODE_TYPES.Literal&&typeof e.value=="boolean",isBooleanEqualityMatcher=e=>{const b=getAccessorValue(e.matcher);if(["toBeTruthy","toBeFalsy"].includes(b))return!0;if(e.args.length!==1)return!1;const d=getFirstMatcherArg(e);return EqualityMatcher.hasOwnProperty(b)&&isBooleanLiteral(d)},isInstanceOfBinaryExpression=(e,b)=>e.type===utils.AST_NODE_TYPES.BinaryExpression&&e.operator==="instanceof"&&isSupportedAccessor(e.right,b),hasOnlyOneArgument=e=>e.arguments.length===1,RULE_NAME$E="prefer-to-be-object",pr=createEslintRule({name:RULE_NAME$E,meta:{type:"suggestion",docs:{description:"enforce using toBeObject()",recommended:!1},fixable:"code",messages:{preferToBeObject:"Prefer toBeObject() to test if a value is an object"},schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expectTypeOf")return;if(isParsedInstanceOfMatcherCall(d,"Object")){e.report({node:d.matcher,messageId:"preferToBeObject",fix:$=>[$.replaceTextRange([d.matcher.range[0],d.matcher.range[1]+8],"toBeObject()")]});return}const{parent:Y}=d.head.node;if(Y?.type!==utils.AST_NODE_TYPES.CallExpression)return;const[q]=Y.arguments;!q||!isBooleanEqualityMatcher(d)||!isInstanceOfBinaryExpression(q,"Object")||e.report({node:d.matcher,messageId:"preferToBeObject",fix($){const F=[$.replaceText(d.matcher,"toBeObject"),$.removeRange([q.left.range[1],q.range[1]])];let V=getAccessorValue(d.matcher)==="toBeFalsy";if(d.args.length){const[G]=d.args;F.push($.remove(G)),V=G.type===utils.AST_NODE_TYPES.Literal&&followTypeAssertionChain$1(G).value===!1}if(V){const G=d.modifiers.find(X=>getAccessorValue(X)==="not");F.push(G?$.removeRange([G.range[0]-1,G.range[1]]):$.insertTextBefore(d.matcher,"not."))}return F}})}}}}),RULE_NAME$D="prefer-to-be-truthy",n=e=>e.type===utils.AST_NODE_TYPES.Literal&&e.value===!0,Er=createEslintRule({name:RULE_NAME$D,meta:{type:"suggestion",docs:{description:"enforce using `toBeTruthy`",recommended:!1},messages:{preferToBeTruthy:"Prefer using `toBeTruthy` to test value is `true`"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);(d?.type==="expect"||d?.type==="expectTypeOf")&&d.args.length===1&&n(getFirstMatcherArg(d))&&EqualityMatcher.hasOwnProperty(getAccessorValue(d.matcher))&&e.report({node:d.matcher,messageId:"preferToBeTruthy",fix:Y=>[Y.replaceText(d.matcher,"toBeTruthy"),Y.remove(d.args[0])]})}}}}),RULE_NAME$C="prefer-to-be-falsy",c$2=e=>e.type===utils.AST_NODE_TYPES.Literal&&e.value===!1,fr=createEslintRule({name:RULE_NAME$C,meta:{type:"suggestion",docs:{description:"enforce using toBeFalsy()",recommended:!1},fixable:"code",schema:[],messages:{preferToBeFalsy:"Prefer using toBeFalsy()"}},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);(d?.type==="expect"||d?.type==="expectTypeOf")&&d.args.length===1&&c$2(getFirstMatcherArg(d))&&EqualityMatcher.hasOwnProperty(getAccessorValue(d.matcher))&&e.report({node:d.matcher,messageId:"preferToBeFalsy",fix:Y=>[Y.replaceText(d.matcher,"toBeFalsy"),Y.remove(d.args[0])]})}}}}),RULE_NAME$B="prefer-to-have-length",lr=createEslintRule({name:RULE_NAME$B,meta:{type:"suggestion",docs:{description:"enforce using toHaveLength()",recommended:!1},fixable:"code",messages:{preferToHaveLength:"Prefer toHaveLength()"},schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const{parent:Y}=d.head.node;if(Y?.type!==utils.AST_NODE_TYPES.CallExpression)return;const[q]=Y.arguments,{matcher:$}=d;!EqualityMatcher.hasOwnProperty(getAccessorValue($))||q?.type!==utils.AST_NODE_TYPES.MemberExpression||!isSupportedAccessor(q.property,"length")||e.report({node:$,messageId:"preferToHaveLength",fix(F){return[F.removeRange([q.property.range[0]-1,q.range[1]]),F.replaceTextRange([$.parent.object.range[1],$.parent.range[1]],".toHaveLength")]}})}}}}),RULE_NAME$A="prefer-equality-matcher",Nr=createEslintRule({name:RULE_NAME$A,meta:{type:"suggestion",docs:{description:"enforce using the built-in quality matchers",recommended:!1},messages:{useEqualityMatcher:"Prefer using one of the equality matchers instead",suggestEqualityMatcher:"Use `{{ equalityMatcher }}`"},hasSuggestions:!0,schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect"||d.args.length===0)return;const{parent:Y}=d.head.node;if(Y?.type!==utils.AST_NODE_TYPES.CallExpression)return;const{arguments:[q],range:[,$]}=Y,{matcher:F}=d,V=getFirstMatcherArg(d);if(q?.type!==utils.AST_NODE_TYPES.BinaryExpression||q.operator!=="==="&&q.operator!=="!=="||!EqualityMatcher.hasOwnProperty(getAccessorValue(F))||!isBooleanLiteral(V))return;const G=V.value,[X]=d.modifiers,z=d.modifiers.some(Q=>getAccessorValue(Q)==="not"),J=(q.operator==="!=="?!G:G)===z,te=Q=>se=>{const{sourceCode:Z}=e;let ee=X&&getAccessorValue(X)!=="not"?`.${getAccessorValue(X)}`:"";return J&&(ee+=`.${ModifierName.not}`),[se.replaceText(q,Z.getText(q.left)),se.replaceTextRange([$,F.parent.range[1]],`${ee}.${Q}`),se.replaceText(V,Z.getText(q.right))]};e.report({messageId:"useEqualityMatcher",suggest:["toBe","toEqual","toStrictEqual"].map(Q=>({messageId:"suggestEqualityMatcher",data:{equalityMatcher:Q},fix:te(Q)})),node:F})}}}}),RULE_NAME$z="prefer-strict-equal",cr=createEslintRule({name:RULE_NAME$z,meta:{type:"suggestion",docs:{description:"enforce strict equal over equal",recommended:!1},messages:{useToStrictEqual:"Use `toStrictEqual()` instead",suggestReplaceWithStrictEqual:"Replace with `toStrictEqual()`"},schema:[],hasSuggestions:!0},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const{matcher:Y}=d;isSupportedAccessor(Y,"toEqual")&&e.report({messageId:"useToStrictEqual",node:Y,suggest:[{messageId:"suggestReplaceWithStrictEqual",fix:q=>[replaceAccessorFixer(q,Y,EqualityMatcher.toStrictEqual)]}]})}}}}),RULE_NAME$y="prefer-expect-resolves",dr=createEslintRule({name:RULE_NAME$y,meta:{type:"suggestion",docs:{description:"enforce using `expect().resolves` over `expect(await ...)` syntax",recommended:!1},fixable:"code",messages:{expectResolves:"Use `expect().resolves` instead"},schema:[]},defaultOptions:[],create:e=>({CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const{parent:Y}=d.head.node;if(Y?.type!==utils.AST_NODE_TYPES.CallExpression)return;const[q]=Y.arguments;q?.type===utils.AST_NODE_TYPES.AwaitExpression&&e.report({node:q,messageId:"expectResolves",fix($){return[$.insertTextBefore(Y,"await "),$.removeRange([q.range[0],q.argument.range[0]]),$.insertTextAfter(Y,".resolves")]}})}})}),RULE_NAME$x="prefer-each",Ar=createEslintRule({name:RULE_NAME$x,meta:{type:"suggestion",docs:{description:"enforce using `each` rather than manual loops",recommended:!1},schema:[],messages:{preferEach:"Prefer using `{{ fn }}.each` rather than a manual loop"}},defaultOptions:[],create(e){const b=[];let d=!1;const Y=()=>b.length===1&&b[0]==="test"?"it":"describe",q=()=>{b.length===0||d||(b.length=0)},$=F=>{b.length===0||d||(e.report({node:F,messageId:"preferEach",data:{fn:Y()}}),b.length=0)};return{ForStatement:q,"ForStatement:exit":$,ForInStatement:q,"ForInStatement:exit":$,ForOfStatement:q,"ForOfStatement:exit":$,CallExpression(F){const{type:V}=parseVitestFnCall(F,e)??{};(V==="hook"||V==="describe"||V==="test")&&b.push(V),V==="test"&&(d=!0)},"CallExpression:exit"(F){const{type:V}=parseVitestFnCall(F,e)??{};V==="test"&&(d=!1)}}}}),RULE_NAME$w="prefer-hooks-on-top",Mr=createEslintRule({name:RULE_NAME$w,meta:{type:"suggestion",docs:{description:"enforce having hooks before any test cases",recommended:!1},messages:{noHookOnTop:"Hooks should come before test cases"},schema:[]},defaultOptions:[],create(e){const b=[!1];return{CallExpression(d){isTypeOfVitestFnCall(d,e,["test"])&&(b[b.length-1]=!0),b[b.length-1]&&isTypeOfVitestFnCall(d,e,["hook"])&&e.report({messageId:"noHookOnTop",node:d}),b.push(!1)},"CallExpression:exit"(){b.pop()}}}}),RULE_NAME$v="prefer-hooks-in-order",a$4=["beforeAll","beforeEach","afterEach","afterAll"],wr=createEslintRule({name:RULE_NAME$v,meta:{type:"suggestion",docs:{description:"enforce having hooks in consistent order",recommended:!1},messages:{reorderHooks:"`{{ currentHook }}` hooks should be before any `{{ previousHook }}` hooks"},schema:[]},defaultOptions:[],create(e){let b=-1,d=!1;return{CallExpression(Y){if(d)return;const q=parseVitestFnCall(Y,e);if(q?.type!=="hook"){b=-1;return}d=!0;const $=q.name,F=a$4.indexOf($);if(F<b){e.report({messageId:"reorderHooks",data:{previousHook:a$4[b],currentHook:$},node:Y}),d=!1;return}b=F},"CallExpression:exit"(Y){if(isTypeOfVitestFnCall(Y,e,["hook"])){d=!1;return}d||(b=-1)}}}}),RULE_NAME$u="prefer-mock-promise-shorthand",l$2=(e,b)=>`${e}${b?"Once":""}`,f=e=>e.body.type!==utils.AST_NODE_TYPES.BlockStatement?e.body:e.body.body[0]?.type===utils.AST_NODE_TYPES.ReturnStatement?e.body.body[0].argument:null,Rr=createEslintRule({name:RULE_NAME$u,meta:{type:"suggestion",docs:{description:"enforce mock resolved/rejected shorthands for promises",recommended:!1},messages:{useMockShorthand:"Prefer {{ replacement }}"},schema:[],fixable:"code"},defaultOptions:[],create(e){const b=(d,Y,q,$=q)=>{if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const F=getNodeName($);if(F!=="Promise.resolve"&&F!=="Promise.reject")return;const V=l$2(F.endsWith("reject")?"mockRejectedValue":"mockResolvedValue",Y);e.report({node:d,messageId:"useMockShorthand",data:{replacement:V},fix(G){const{sourceCode:X}=e;return $.arguments.length>1?null:[G.replaceText(d,V),G.replaceText(q,$.arguments.length===1?X.getText($.arguments[0]):"undefined")]}})};return{CallExpression(d){if(d.callee.type!==utils.AST_NODE_TYPES.MemberExpression||!isSupportedAccessor(d.callee.property)||d.arguments.length===0)return;const Y=getAccessorValue(d.callee.property),q=Y.endsWith("Once");if(Y===l$2("mockReturnValue",q))b(d.callee.property,q,d.arguments[0]);else if(Y===l$2("mockImplementation",q)){const[$]=d.arguments;if(!isFunction($)||$.params.length!==0)return;b(d.callee.property,q,$,f($))}}}}}),a$3=node_module.createRequire(typeof document>"u"?require("url").pathToFileURL(__filename).href:_documentCurrentScript&&_documentCurrentScript.tagName.toUpperCase()==="SCRIPT"&&_documentCurrentScript.src||new URL("index.cjs",document.baseURI).href),c$1=node_module.createRequire(a$3.resolve("eslint"));c$1.resolve("espree");const p=new Set([utils.AST_NODE_TYPES.Program,utils.AST_NODE_TYPES.BlockStatement,utils.AST_NODE_TYPES.SwitchCase,utils.AST_NODE_TYPES.SwitchStatement]),isValidParent=e=>p.has(e),isTokenASemicolon=e=>e.value===";"&&e.type===utils.AST_TOKEN_TYPES.Punctuator,getActualLastToken=(e,b)=>{const d=e.getLastToken(b),Y=e.getTokenBefore(d),q=e.getTokenAfter(d);return Y&&q&&Y.range[0]>=b.range[0]&&isTokenASemicolon(d)&&d.loc.start.line!==Y.loc.end.line&&d.loc.end.line===q.loc.start.line?Y:d},getPaddingLineSequences=(e,b,d)=>{const Y=[];let q=getActualLastToken(d,e);if(b.loc.start.line-e.loc.end.line>=2)do{const $=d.getTokenAfter(q,{includeComments:!0});$.loc.start.line-q.loc.end.line>=2&&Y.push([q,$]),q=$}while(q.range[0]<b.range[0]);return Y},areTokensOnSameLine=(e,b)=>e.loc.end.line===b.loc.start.line,E$1=e=>e.type===utils.AST_NODE_TYPES.TSAsExpression||e.type===utils.AST_NODE_TYPES.TSTypeAssertion,followTypeAssertionChain=e=>E$1(e)?followTypeAssertionChain(e.expression):e,RULE_NAME$t="prefer-vi-mocked",m$4=["Mock","MockedFunction","MockedClass","MockedObject"],Lr=createEslintRule({name:RULE_NAME$t,meta:{type:"suggestion",docs:{description:"require `vi.mocked()` over `fn as Mock`",requiresTypeChecking:!0,recommended:!1},fixable:"code",messages:{useViMocked:"Prefer `vi.mocked()`"},schema:[]},defaultOptions:[],create(e){function b(d){const{typeAnnotation:Y}=d;if(Y.type!==utils.AST_NODE_TYPES.TSTypeReference)return;const{typeName:q}=Y;if(q.type!==utils.AST_NODE_TYPES.Identifier||!m$4.includes(q.name))return;const $=e.sourceCode.text.slice(...followTypeAssertionChain(d.expression).range);e.report({node:d,messageId:"useViMocked",fix(F){return F.replaceText(d,`vi.mocked(${$})`)}})}return{TSAsExpression(d){d.parent.type!==utils.AST_NODE_TYPES.TSAsExpression&&b(d)},TSTypeAssertion(d){b(d)}}}}),RULE_NAME$s="prefer-snapshot-hint",E=["toMatchSnapshot","toThrowErrorMatchingSnapshot"],x$2=E,S$3=e=>{if(e.args.length===0)return!0;if(!isSupportedAccessor(e.matcher,"toMatchSnapshot"))return e.args.length!==1;if(e.args.length===2)return!1;const[b]=e.args;return!isStringNode(b)},ur=createEslintRule({name:RULE_NAME$s,meta:{type:"suggestion",docs:{description:"enforce including a hint with external snapshots",recommended:!1},messages:{missingHint:"You should provide a hint for this snapshot"},schema:[{type:"string",enum:["always","multi"]}]},defaultOptions:["multi"],create(e,[b]){const d=[];let Y=0;const q=[],$=()=>{for(const G of d)S$3(G)&&e.report({messageId:"missingHint",node:G.matcher})},F=()=>{Y++},V=()=>{Y--,b==="always"&&($(),d.length=0),b==="multi"&&Y===0&&(d.length>1&&$(),d.length=0)};return{"Program:exit"(){F(),V()},FunctionExpression:F,"FunctionExpression:exit":V,ArrowFunctionExpression:F,"ArrowFunctionExpression:exit":V,"CallExpression:exit"(G){isTypeOfVitestFnCall(G,e,["describe","test"])&&(Y=q.pop()??0)},CallExpression(G){const X=parseVitestFnCall(G,e);if(X?.type!=="expect"){(X?.type==="describe"||X?.type==="test")&&(q.push(Y),Y=0);return}const z=getAccessorValue(X.matcher);x$2.includes(z)&&d.push(X)}}}}),RULE_NAME$r="valid-describe-callback",o=e=>{const[b]=e,d=e[e.length-1];return{start:b.loc.start,end:d.loc.end}},i$1=(e,b)=>e.members.every(d=>getAccessorValue(d)!=="each")&&b.params.length,u$2=(e,b)=>{e.body.forEach(d=>{d.type===utils.AST_NODE_TYPES.ReturnStatement&&b.report({messageId:"unexpectedReturnInDescribe",node:d})})},Ur=createEslintRule({name:RULE_NAME$r,meta:{type:"problem",docs:{description:"enforce valid describe callback",recommended:!1},messages:{nameAndCallback:"Describe requires a name and callback arguments",secondArgumentMustBeFunction:"Second argument must be a function",unexpectedDescribeArgument:"Unexpected argument in describe callback",unexpectedReturnInDescribe:"Unexpected return statement in describe callback"},schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="describe"||d?.members[0]?.type===utils.AST_NODE_TYPES.Identifier&&d.members[0].name==="todo")return;if(b.arguments.length<1)return e.report({messageId:"nameAndCallback",loc:b.loc});const[,Y,q]=b.arguments;if(!Y){e.report({messageId:"nameAndCallback",loc:o(b.arguments)});return}if(!isFunction(Y)){if(q&&isFunction(q)){i$1(d,q)&&e.report({messageId:"unexpectedDescribeArgument",node:q}),q.body.type===utils.AST_NODE_TYPES.CallExpression&&e.report({messageId:"unexpectedReturnInDescribe",node:q}),q.body.type===utils.AST_NODE_TYPES.BlockStatement&&u$2(q.body,e);return}e.report({messageId:"secondArgumentMustBeFunction",loc:o(b.arguments)});return}i$1(d,Y)&&e.report({messageId:"unexpectedDescribeArgument",node:Y}),Y.body.type===utils.AST_NODE_TYPES.CallExpression&&e.report({messageId:"unexpectedReturnInDescribe",node:Y}),Y.body.type===utils.AST_NODE_TYPES.BlockStatement&&u$2(Y.body,e)}}}}),RULE_NAME$q="require-top-level-describe",_r=createEslintRule({name:RULE_NAME$q,meta:{docs:{description:"enforce that all tests are in a top-level describe",recommended:!1},messages:{tooManyDescribes:"There should not be more than {{ max }} describe{{ s }} at the top level",unexpectedTestCase:"All test cases must be wrapped in a describe block",unexpectedHook:"All hooks must be wrapped in a describe block"},type:"suggestion",schema:[{type:"object",properties:{maxNumberOfTopLevelDescribes:{type:"number",minimum:1,default:1/0}},additionalProperties:!1}]},defaultOptions:[{maxNumberOfTopLevelDescribes:1/0}],create(e,b){const d=b[0].maxNumberOfTopLevelDescribes;let Y=0,q=0;return{CallExpression($){const F=parseVitestFnCall($,e);if(F){if(F.type==="describe"){q++,q===1&&(Y++,Y>d&&e.report({node:$,messageId:"tooManyDescribes",data:{max:d,s:d===1?"":"s"}}));return}if(q===0){if(F.type==="test"&&(F.members.length===0||!F.members.every(V=>"name"in V&&V.name==="extend"))){e.report({node:$,messageId:"unexpectedTestCase"});return}F.type==="hook"&&e.report({node:$,messageId:"unexpectedHook"})}}},"CallExpression:exit"($){isTypeOfVitestFnCall($,e,["describe"])&&q--}}}}),RULE_NAME$p="require-to-throw-message",Tr=createEslintRule({name:RULE_NAME$p,meta:{type:"suggestion",docs:{description:"require toThrow() to be called with an error message",recommended:!1},schema:[],messages:{addErrorMessage:"Add an error message to {{ matcherName }}()"}},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const{matcher:Y}=d,q=getAccessorValue(Y);d.args.length===0&&["toThrow","toThrowError"].includes(q)&&!d.modifiers.some($=>getAccessorValue($)==="not")&&e.report({messageId:"addErrorMessage",data:{matcherName:q},node:Y})}}}}),RULE_NAME$o="require-hook",S$2=(e,b)=>parseVitestFnCall(e,b)?!0:!!getNodeName(e)?.startsWith("vi"),m$3=e=>e.type===utils.AST_NODE_TYPES.Literal&&e.value===null||isIdentifier(e,"undefined"),a$2=(e,b,d=[])=>{switch(e.type){case utils.AST_NODE_TYPES.ExpressionStatement:return a$2(e.expression,b,d);case utils.AST_NODE_TYPES.CallExpression:return!(S$2(e,b)||d.includes(getNodeName(e)));case utils.AST_NODE_TYPES.VariableDeclaration:return e.kind==="const"?!1:e.declarations.some(({init:Y})=>Y!==null&&!m$3(Y));default:return!1}},br=createEslintRule({name:RULE_NAME$o,meta:{docs:{description:"require setup and teardown to be within a hook",recommended:!1},messages:{useHook:"This should be done within a hook"},type:"suggestion",schema:[{type:"object",properties:{allowedFunctionCalls:{type:"array",items:{type:"string"}}},additionalProperties:!1}]},defaultOptions:[{allowedFunctionCalls:[]}],create(e,b){const d=Y=>{for(const q of Y)a$2(q,e,b[0].allowedFunctionCalls)&&e.report({node:q,messageId:"useHook"})};return{Program(Y){d(Y.body)},CallExpression(Y){if(!isTypeOfVitestFnCall(Y,e,["describe"])||Y.arguments.length<2)return;const[,q]=Y.arguments;!isFunction(q)||q.body.type!==utils.AST_NODE_TYPES.BlockStatement||d(q.body.body)}}}}),RULE_NAME$n="require-local-test-context-for-concurrent-snapshots",hr=createEslintRule({name:RULE_NAME$n,meta:{docs:{description:"require local Test Context for concurrent snapshot tests",recommended:!1},messages:{requireLocalTestContext:"Use local Test Context instead"},type:"problem",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);d===null||d.type!=="expect"||d.type==="expect"&&d.head.type==="testContext"||!["toMatchSnapshot","toMatchInlineSnapshot","toMatchFileSnapshot","toThrowErrorMatchingSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(b.callee?.property.name)||!e.sourceCode.getAncestors(b).some(Y=>Y.type!==utils.AST_NODE_TYPES.CallExpression||!isTypeOfVitestFnCall(Y,e,["describe","test"])?!1:Y.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(Y.callee.property,"concurrent"))||e.report({node:b,messageId:"requireLocalTestContext"})}}}}),RULE_NAME$m="prefer-todo",S$1=e=>e.members.some(b=>getAccessorValue(b)!=="skip")||e.name.startsWith("x")?!1:!e.name.startsWith("f");function T$1(e){return isFunction(e)?e.body.type===utils.AST_NODE_TYPES.BlockStatement&&!e.body.body.length:!1}function a$1(e,b){return e.members.length?replaceAccessorFixer(b,e.members[0],"todo"):b.replaceText(e.head.node,`${e.head.local}.todo`)}const gr=createEslintRule({name:RULE_NAME$m,meta:{type:"layout",docs:{description:"enforce using `test.todo`",recommended:!1},messages:{emptyTest:"Prefer todo test case over empty test case",unimplementedTest:"Prefer todo test case over unimplemented test case"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const[d,Y]=b.arguments,q=parseVitestFnCall(b,e);!d||q?.type!=="test"||!S$1(q)||!isStringNode(d)||(Y&&T$1(Y)&&e.report({messageId:"emptyTest",node:b,fix:$=>[$.removeRange([d.range[1],Y.range[1]]),a$1(q,$)]}),hasOnlyOneArgument(b)&&e.report({messageId:"unimplementedTest",node:b,fix:$=>a$1(q,$)}))}}}}),RULE_NAME$l="prefer-spy-on",u$1=e=>"object"in e?e.object:e.callee.type===utils.AST_NODE_TYPES.MemberExpression?e.callee.object:null,a=e=>{if(e.type!==utils.AST_NODE_TYPES.CallExpression&&e.type!==utils.AST_NODE_TYPES.MemberExpression)return null;const b=u$1(e);return b?b.type===utils.AST_NODE_TYPES.Identifier?e.type===utils.AST_NODE_TYPES.CallExpression&&getNodeName(e.callee)==="vi.fn"?e:null:a(b):null},S=(e,b)=>{if(e.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&e.parent.property.type===utils.AST_NODE_TYPES.Identifier&&e.parent.property.name==="mockImplementation")return"";const[d]=e.arguments,Y=d&&b.sourceCode.getText(d);return Y?`.mockImplementation(${Y})`:".mockImplementation()"},kr=createEslintRule({name:RULE_NAME$l,meta:{type:"suggestion",docs:{description:"enforce using `vi.spyOn`",recommended:!1},messages:{useViSpayOn:"Use `vi.spyOn` instead"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{AssignmentExpression(b){const{left:d,right:Y}=b;if(d.type!==utils.AST_NODE_TYPES.MemberExpression)return;const q=a(Y);q&&e.report({node:b,messageId:"useViSpayOn",fix($){const F=d.property.type===utils.AST_NODE_TYPES.Identifier&&!d.computed?"'":"",V=S(q,e);return[$.insertTextBefore(d,"vi.spyOn("),$.replaceTextRange([d.object.range[1],d.property.range[0]],`, ${F}`),$.replaceTextRange([d.property.range[1],q.range[1]],`${F})${V}`)]}})}}}}),RULE_NAME$k="prefer-comparison-matcher",g$2=e=>isStringNode(e)||e?.type===utils.AST_NODE_TYPES.TemplateLiteral,C=e=>g$2(e.left)||g$2(e.right),M$1=e=>{switch(e){case">":return"<=";case"<":return">=";case">=":return"<";case"<=":return">"}return null},O$1=(e,b)=>{switch(b?M$1(e):e){case">":return"toBeGreaterThan";case"<":return"toBeLessThan";case">=":return"toBeGreaterThanOrEqual";case"<=":return"toBeLessThanOrEqual"}return null},xr=createEslintRule({name:RULE_NAME$k,meta:{type:"suggestion",docs:{description:"enforce using the built-in comparison matchers",recommended:!1},schema:[],fixable:"code",messages:{useToBeComparison:"Prefer using `{{ preferredMatcher }}` instead"}},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect"||d.args.length===0)return;const{parent:Y}=d.head.node;if(Y?.type!==utils.AST_NODE_TYPES.CallExpression)return;const{arguments:[q],range:[,$]}=Y,{matcher:F}=d,V=getFirstMatcherArg(d);if(q?.type!==utils.AST_NODE_TYPES.BinaryExpression||C(q)||!EqualityMatcher.hasOwnProperty(getAccessorValue(F))||!isBooleanLiteral(V))return;const[G]=d.modifiers,X=d.modifiers.some(J=>getAccessorValue(J)==="not"),z=O$1(q.operator,V.value===X);z&&e.report({fix(J){const{sourceCode:te}=e,Q=G&&getAccessorValue(G)!=="not"?`.${getAccessorValue(G)}`:"";return[J.replaceText(q,te.getText(q.left)),J.replaceTextRange([$,F.parent.range[1]],`${Q}.${z}`),J.replaceText(V,te.getText(q.right))]},messageId:"useToBeComparison",data:{preferredMatcher:z},node:F})}}}}),RULE_NAME$j="prefer-describe-function-title",Cr=createEslintRule({name:RULE_NAME$j,meta:{type:"problem",docs:{description:"enforce using a function as a describe title over an equivalent string",recommended:!1},fixable:"code",schema:[],messages:{preferFunction:"Enforce using a function over an equivalent string"}},defaultOptions:[],create(e){return{CallExpression(b){if(b.arguments.length<2)return;const d=getModuleScope(e,b),[Y]=b.arguments;if(Y.type===utils.AST_NODE_TYPES.MemberExpression&&Y.object.type===utils.AST_NODE_TYPES.Identifier&&Y.property.type===utils.AST_NODE_TYPES.Identifier){const F=Y.object.name;if(d?.set.get(F)?.defs[0]?.type!==scopeManager.DefinitionType.ImportBinding||Y.property.name!=="name")return;e.report({node:Y,messageId:"preferFunction",fix(V){return V.replaceText(Y,F)}});return}if(Y.type!==utils.AST_NODE_TYPES.Literal||typeof Y.value!="string")return;const q=Y.value;if(parseVitestFnCall(b,e)?.type!=="describe")return;const $=d?.set.get(q)?.defs[0];if($?.type===scopeManager.DefinitionType.ImportBinding){if(parsePluginSettings(e.settings).typecheck){const F=utils.ESLintUtils.getParserServices(e).getTypeAtLocation($.node);if(!isClassOrFunctionType(F))return}e.report({node:Y,messageId:"preferFunction",fix(F){return F.replaceText(Y,q)}})}}}}}),RULE_NAME$i="prefer-to-contain",T=e=>e.type===utils.AST_NODE_TYPES.CallExpression&&e.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(e.callee.property,"includes")&&hasOnlyOneArgument(e)&&e.arguments[0].type!==utils.AST_NODE_TYPES.SpreadElement,vr=createEslintRule({name:RULE_NAME$i,meta:{docs:{description:"enforce using toContain()",recommended:!1},messages:{useToContain:"Use toContain() instead"},fixable:"code",type:"suggestion",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect"||d.args.length===0)return;const{parent:Y}=d.head.node;if(Y?.type!==utils.AST_NODE_TYPES.CallExpression)return;const{arguments:[q],range:[,$]}=Y,{matcher:F}=d,V=getFirstMatcherArg(d);if(!q||V.type===utils.AST_NODE_TYPES.SpreadElement||!EqualityMatcher.hasOwnProperty(getAccessorValue(F))||!isBooleanLiteral(V)||!T(q))return;const G=d.modifiers.some(X=>getAccessorValue(X)==="not");e.report({fix(X){const{sourceCode:z}=e,J=V.value===G;return[X.removeRange([q.callee.property.range[0]-1,q.range[1]]),X.replaceTextRange([$,F.parent.range[1]],J?`.${ModifierName.not}.toContain`:".toContain"),X.replaceText(d.args[0],z.getText(q.arguments[0]))]},messageId:"useToContain",node:F})}}}}),RULE_NAME$h="prefer-expect-assertions",L$1=e=>{let b=e;for(;b;){if(b.parent?.type===utils.AST_NODE_TYPES.BlockStatement)return b.parent.body[0]===b;if(b.parent?.type===utils.AST_NODE_TYPES.ArrowFunctionExpression)return!0;b=b.parent}throw new Error("Could not find parent block statement")},y$2=(e,b,d)=>({messageId:"suggestRemovingExtraArguments",fix:Y=>removeExtraArgumentsFixer(Y,e,b,d)}),Br=createEslintRule({name:"prefer-expect-assertions",meta:{docs:{description:"enforce using expect assertions instead of callbacks",recommended:!1},messages:{hasAssertionsTakesNoArguments:"`expect.hasAssertions` expects no arguments",assertionsRequiresOneArgument:"`expect.assertions` excepts a single argument of type number",assertionsRequiresNumberArgument:"This argument should be a number",haveExpectAssertions:"Every test should have either `expect.assertions(<number of assertions>)` or `expect.hasAssertions()` as its first expression",suggestAddingHasAssertions:"Add `expect.hasAssertions()`",suggestAddingAssertions:"Add `expect.assertions(<number of assertions>)`",suggestRemovingExtraArguments:"Remove extra arguments"},type:"suggestion",hasSuggestions:!0,schema:[{type:"object",properties:{onlyFunctionsWithAsyncKeyword:{type:"boolean"},onlyFunctionsWithExpectInLoop:{type:"boolean"},onlyFunctionsWithExpectInCallback:{type:"boolean"}},additionalProperties:!1}]},defaultOptions:[{onlyFunctionsWithAsyncKeyword:!1,onlyFunctionsWithExpectInCallback:!1,onlyFunctionsWithExpectInLoop:!1}],create(e,[b]){let d=0,Y=!1,q=!1,$=!1,F=null,V=!1,G=!1;const X=Z=>!!(!b.onlyFunctionsWithAsyncKeyword&&!b.onlyFunctionsWithExpectInCallback&&!b.onlyFunctionsWithExpectInLoop||b.onlyFunctionsWithAsyncKeyword&&Z.async||b.onlyFunctionsWithExpectInCallback&&Y||b.onlyFunctionsWithExpectInLoop&&q);function z(Z,ee){if(getAccessorValue(Z.members[0])==="hasAssertions"){Z.args.length&&e.report({messageId:"hasAssertionsTakesNoArguments",node:Z.matcher,suggest:[y$2(e,ee,0)]});return}if(Z.args.length!==1){let{loc:oe}=Z.matcher;const ne=[];Z.args.length&&(oe=Z.args[1].loc,ne.push(y$2(e,ee,1))),e.report({messageId:"assertionsRequiresOneArgument",suggest:ne,loc:oe});return}const[re]=Z.args;re.type===utils.AST_NODE_TYPES.Literal&&typeof re.value=="number"&&Number.isInteger(re.value)||e.report({messageId:"assertionsRequiresNumberArgument",node:re})}const J=()=>V&&d++,te=()=>V&&d--,Q=()=>G=!0,se=()=>G=!1;return{FunctionExpression:J,"FunctionExpression:exit":te,ArrowFunctionExpression:J,"ArrowFunctionExpression:exit":te,ForStatement:Q,"ForStatement:exit":se,ForInStatement:Q,"ForInStatement:exit":se,ForOfStatement:Q,"ForOfStatement:exit":se,CallExpression(Z){const ee=parseVitestFnCall(Z,e);if(ee?.type==="test"){V=!0;return}ee?.head.type==="testContext"&&ee.members[0]&&ee.members[0].type===utils.AST_NODE_TYPES.Identifier&&ee.members[0].name==="expect"&&(F=`${ee.head.local}`),ee?.type==="expect"&&V&&(d===1&&L$1(Z)&&ee.head.node.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&ee.members.length===1&&["assertions","hasAssertions"].includes(getAccessorValue(ee.members[0]))&&(z(ee,Z),$=!0),G&&(q=!0),d>1&&(Y=!0))},"CallExpression:exit"(Z){if(!isTypeOfVitestFnCall(Z,e,["test"])||(V=!1,Z.arguments.length<2))return;const[,ee]=Z.arguments;if(!isFunction(ee)||!X(ee))return;if(q=!1,Y=!1,$){$=!1;return}const re=[];if(ee.body.type===utils.AST_NODE_TYPES.BlockStatement){const oe=F?`${F}.`:"";re.push(["suggestAddingHasAssertions",`${oe}expect.hasAssertions();`],["suggestAddingAssertions",`${oe}expect.assertions();`])}e.report({messageId:"haveExpectAssertions",node:Z,suggest:re.map(([oe,ne])=>({messageId:oe,fix:ie=>ie.insertTextBeforeRange([ee.body.range[0]+1,ee.body.range[1]],ne)}))})}}}});var PaddingType=(e=>(e[e.Any=0]="Any",e[e.Always=1]="Always",e))(PaddingType||{}),StatementType=(e=>(e[e.Any=0]="Any",e[e.AfterAllToken=1]="AfterAllToken",e[e.AfterEachToken=2]="AfterEachToken",e[e.BeforeAllToken=3]="BeforeAllToken",e[e.BeforeEachToken=4]="BeforeEachToken",e[e.DescribeToken=5]="DescribeToken",e[e.ExpectToken=6]="ExpectToken",e[e.ExpectTypeOfToken=7]="ExpectTypeOfToken",e[e.FdescribeToken=8]="FdescribeToken",e[e.FitToken=9]="FitToken",e[e.ItToken=10]="ItToken",e[e.TestToken=11]="TestToken",e[e.XdescribeToken=12]="XdescribeToken",e[e.XitToken=13]="XitToken",e[e.XtestToken=14]="XtestToken",e))(StatementType||{});const x$1=(e,b,d)=>{const{sourceCode:Y,ruleContext:q}=d;getPaddingLineSequences(e,b,Y).length>0||q.report({node:b,messageId:"missingPadding",fix($){let F=getActualLastToken(Y,e);const V=Y.getFirstTokenBetween(F,b,{includeComments:!0,filter(X){return areTokensOnSameLine(F,X)?(F=X,!1):!0}})||b,G=areTokensOnSameLine(F,V)?`

`:`
`;return $.insertTextAfter(F,G)}})},m$2={0:()=>!0,1:x$1},y$1=()=>{let e=null;return{get prevNode(){return e.prevNode},set prevNode(b){e.prevNode=b},enter(){e={upper:e,prevNode:null}},exit(){e=e.upper}}},i=e=>(b,d)=>{let Y=b;if(Y.type===utils.AST_NODE_TYPES.ExpressionStatement){Y.expression.type===utils.AST_NODE_TYPES.AwaitExpression&&(Y=Y.expression.argument);const q=d.getFirstToken(Y);return q?.type===utils.AST_TOKEN_TYPES.Identifier&&q.value===e}return!1},A$1={0:()=>!0,1:i("afterAll"),2:i("afterEach"),3:i("beforeAll"),4:i("beforeEach"),5:i("describe"),6:i("expect"),7:i("expectTypeOf"),8:i("fdescribe"),9:i("fit"),10:i("it"),11:i("test"),12:i("xdescribe"),13:i("xit"),14:i("xtest")},l$1=(e,b,d)=>{let Y=e;const{sourceCode:q}=d;for(;Y.type===utils.AST_NODE_TYPES.LabeledStatement;)Y=Y.body;return Array.isArray(b)?b.some($=>l$1(Y,$,d)):A$1[b](Y,q)},N$2=(e,b,d)=>{const{configs:Y}=d,q=$=>m$2[$](e,b,d);for(let $=Y.length-1;$>=0;--$){const{prevStatementType:F,nextStatementType:V,paddingType:G}=Y[$];if(l$1(e,F,d)&&l$1(b,V,d))return q(G)}return q(0)},u=(e,b)=>{const{scopeInfo:d}=b;isValidParent(e?.parent.type)&&(d.prevNode&&N$2(d.prevNode,e,b),d.prevNode=e)},createPaddingRule=(e,b,d,Y=!1)=>createEslintRule({name:e,meta:{docs:{description:b},fixable:"whitespace",deprecated:Y,messages:{missingPadding:"expect blank line before this statement"},schema:[],type:"suggestion"},defaultOptions:[],create(q){const $={ruleContext:q,sourceCode:q.sourceCode??q.getSourceCode(),scopeInfo:y$1(),configs:d},{scopeInfo:F}=$;return{Program:F.enter,"Program:exit":F.exit,BlockStatement:F.enter,"BlockStatement:exit":F.exit,SwitchStatement:F.enter,"SwitchStatement:exit":F.exit,":statement":V=>u(V,$),SwitchCase(V){u(V,$),F.enter()},"SwitchCase:exit":F.exit}}}),RULE_NAME$g="padding-around-after-all-blocks",config$6=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.AfterAllToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.AfterAllToken,nextStatementType:StatementType.Any}],Ir=createPaddingRule(RULE_NAME$g,"Enforce padding around `afterAll` blocks",config$6),RULE_NAME$f="padding-around-after-each-blocks",config$5=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.AfterEachToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.AfterEachToken,nextStatementType:StatementType.Any}],yr=createPaddingRule(RULE_NAME$f,"Enforce padding around `afterEach` blocks",config$5),RULE_NAME$e="padding-around-before-all-blocks",config$4=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.BeforeAllToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.BeforeAllToken,nextStatementType:StatementType.Any}],Sr=createPaddingRule(RULE_NAME$e,"Enforce padding around `beforeAll` blocks",config$4),RULE_NAME$d="padding-around-before-each-blocks",config$3=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.BeforeEachToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.BeforeEachToken,nextStatementType:StatementType.Any}],Dr=createPaddingRule(RULE_NAME$d,"Enforce padding around `beforeEach` blocks",config$3),RULE_NAME$c="padding-around-describe-blocks",config$2=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:[StatementType.DescribeToken,StatementType.FdescribeToken,StatementType.XdescribeToken]},{paddingType:PaddingType.Always,prevStatementType:[StatementType.DescribeToken,StatementType.FdescribeToken,StatementType.XdescribeToken],nextStatementType:StatementType.Any}],Hr=createPaddingRule(RULE_NAME$c,"Enforce padding around `describe` blocks",config$2),RULE_NAME$b="padding-around-expect-groups",config$1=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.ExpectToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.ExpectToken,nextStatementType:StatementType.Any},{paddingType:PaddingType.Any,prevStatementType:StatementType.ExpectToken,nextStatementType:StatementType.ExpectToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.ExpectTypeOfToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.ExpectTypeOfToken,nextStatementType:StatementType.Any},{paddingType:PaddingType.Any,prevStatementType:StatementType.ExpectTypeOfToken,nextStatementType:StatementType.ExpectTypeOfToken}],qr=createPaddingRule(RULE_NAME$b,"Enforce padding around `expect` groups",config$1),RULE_NAME$a="padding-around-test-blocks",config=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:[StatementType.TestToken,StatementType.ItToken,StatementType.FitToken,StatementType.XitToken,StatementType.XtestToken]},{paddingType:PaddingType.Always,prevStatementType:[StatementType.TestToken,StatementType.ItToken,StatementType.FitToken,StatementType.XitToken,StatementType.XtestToken],nextStatementType:StatementType.Any}],Fr=createPaddingRule(RULE_NAME$a,"Enforce padding around `test` blocks",config),RULE_NAME$9="padding-around-all",Or=createPaddingRule(RULE_NAME$9,"Enforce padding around vitest functions",[...config$6,...config$5,...config$4,...config$3,...config$2,...config$1,...config]),RULE_NAME$8="valid-expect-in-promise",w=["toRejectWith","toResolveWith"],c=e=>{if(e.type===utils.AST_NODE_TYPES.CallExpression&&e.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(e.callee.property)){if(e.arguments.length===0)return!1;switch(getAccessorValue(e.callee.property)){case"then":return e.arguments.length<3;case"catch":case"finally":return e.arguments.length<2}}return!1},k$1=(e,b)=>{const d=parseVitestFnCall(e,b);if(d?.type!=="test")return!1;const Y=d.members.some(F=>getAccessorValue(F)==="each");if(Y&&e.callee.type!==utils.AST_NODE_TYPES.TaggedTemplateExpression)return!0;const[,q]=e.arguments,$=Number(Y);return q&&isFunction(q)&&q.params.length===1+$},x=(e,b)=>{const{name:d}=b;if(e.argument===null)return!1;if(e.argument.type===utils.AST_NODE_TYPES.CallExpression&&e.argument.arguments.length>0){const Y=getNodeName(e.argument);if(["Promise.all","Promise.allSettled"].includes(Y)){const[q]=e.argument.arguments;if(q.type===utils.AST_NODE_TYPES.ArrayExpression&&q.elements.some($=>$&&isIdentifier($,d)))return!0}if(["Promise.resolve","Promise.reject"].includes(Y)&&e.argument.arguments.length===1)return isIdentifier(e.argument.arguments[0],d)}return isIdentifier(e.argument,d)},h=(e,b)=>{for(const d of b)if(d?.type===utils.AST_NODE_TYPES.AwaitExpression&&isIdentifier(d.argument,e)||d?.type===utils.AST_NODE_TYPES.ArrayExpression&&h(e,d.elements))return!0;return!1},M=(e,b)=>{let d=b;for(;d;){if(d.type===utils.AST_NODE_TYPES.CallExpression){if(h(e,d.arguments))return!0;d=d.callee}if(d.type!==utils.AST_NODE_TYPES.MemberExpression)break;d=d.object}return!1},N$1=e=>{let b=e,d=e;for(;d&&(d.type===utils.AST_NODE_TYPES.CallExpression&&(b=d,d=d.callee),d.type===utils.AST_NODE_TYPES.MemberExpression);)d=d.object;return b},m$1=(e,b,d)=>{const{name:Y}=e;for(const q of b)if(!(q.range[0]<=e.range[0])){if(q.type===utils.AST_NODE_TYPES.ReturnStatement)return x(q,e);if(q.type===utils.AST_NODE_TYPES.ExpressionStatement){if(q.expression.type===utils.AST_NODE_TYPES.CallExpression){if(M(Y,q.expression))return!0;const $=N$1(q.expression),F=parseVitestFnCall(q.expression,d);if(F?.type==="expect"&&$.arguments.length>0&&isIdentifier($.arguments[0],Y)&&F.members.some(V=>{const G=getAccessorValue(V);return G===ModifierName.resolves||G===ModifierName.rejects}))return!0}if(q.expression.type===utils.AST_NODE_TYPES.AwaitExpression&&x(q.expression,e))return!0;if(q.expression.type===utils.AST_NODE_TYPES.AssignmentExpression){if(isIdentifier(q.expression.left,Y)&&getNodeName(q.expression.right)?.startsWith(`${Y}.`)&&c(q.expression.right))continue;break}}if(q.type===utils.AST_NODE_TYPES.BlockStatement&&m$1(e,q.body,d))return!0}return!1},y=e=>{let b=e;for(;b;){if(b.type===utils.AST_NODE_TYPES.BlockStatement)return b.body;b=b.parent}throw new Error("Could not find BlockStatement - please file a github issue at https://github.com/vitest-dev/eslint-plugin-vitest")},I$1=(e,b)=>{let d=e;for(;d;){if(isFunction(d))return d=d.parent,d?.type===utils.AST_NODE_TYPES.CallExpression&&isTypeOfVitestFnCall(d,b,["test"]);d=d.parent}return!1},P=(e,b)=>{const d=y(e);return isIdentifier(e.id)?m$1(e.id,d,b):!0},Vr=createEslintRule({name:RULE_NAME$8,meta:{docs:{description:"require promises that have expectations in their chain to be valid"},messages:{expectInFloatingPromise:"This promise should either be returned or awaited to ensure the expects in its chain are called"},type:"suggestion",schema:[]},defaultOptions:[{alwaysAwait:!1,asyncMatchers:w,minArgs:1,maxArgs:1}],create(e){let b=!1;const d=[];return{CallExpression(Y){if(k$1(Y,e)){b=!0;return}if(c(Y)){d.unshift(!1);return}d.length>0&&isTypeOfVitestFnCall(Y,e,["expect"])&&(d[0]=!0)},"CallExpression:exit"(Y){if(b){isTypeOfVitestFnCall(Y,e,["test"])&&(b=!1);return}if(!c(Y)||!d.shift())return;const{parent:q}=findTopMostCallExpression(Y);if(!(!q||!I$1(q,e))){switch(q.type){case utils.AST_NODE_TYPES.VariableDeclarator:{if(P(q,e))return;break}case utils.AST_NODE_TYPES.AssignmentExpression:{if(q.left.type===utils.AST_NODE_TYPES.Identifier&&m$1(q.left,y(q),e))return;break}case utils.AST_NODE_TYPES.ExpressionStatement:break;case utils.AST_NODE_TYPES.ReturnStatement:case utils.AST_NODE_TYPES.AwaitExpression:default:return}e.report({messageId:"expectInFloatingPromise",node:q})}}}}}),RULE_NAME$7="prefer-strict-boolean-matchers",Pr=createEslintRule({name:RULE_NAME$7,meta:{type:"suggestion",docs:{description:"enforce using `toBe(true)` and `toBe(false)` over matchers that coerce types to boolean",recommended:!1},messages:{preferToBeTrue:"Prefer using `toBe(true)` to test value is `true`",preferToBeFalse:"Prefer using `toBe(false)` to test value is `false`"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(!(d?.type==="expect"||d?.type==="expectTypeOf"))return;const Y=getAccessorValue(d.matcher);Y==="toBeFalsy"&&e.report({node:d.matcher,messageId:"preferToBeFalse",fix:q=>[q.replaceText(d.matcher,"toBe"),q.insertTextAfterRange([d.matcher.range[0],d.matcher.range[1]+1],"false")]}),Y==="toBeTruthy"&&e.report({node:d.matcher,messageId:"preferToBeTrue",fix:q=>[q.replaceText(d.matcher,"toBe"),q.insertTextAfterRange([d.matcher.range[0],d.matcher.range[1]+1],"true")]})}}}}),RULE_NAME$6="require-mock-type-parameters",Gr=createEslintRule({name:RULE_NAME$6,meta:{type:"suggestion",docs:{description:"enforce using type parameters with vitest mock functions",recommended:!1},messages:{noTypeParameter:"Missing type parameters"},fixable:"code",schema:[{type:"object",properties:{checkImportFunctions:{type:"boolean"}},additionalProperties:!1}]},defaultOptions:[{checkImportFunctions:!1}],create(e,[b]){return{CallExpression(d){const Y=parseVitestFnCall(d,e);if(Y?.type==="vi")for(const q of Y?.members)!("name"in q)||q.parent.parent.typeArguments!==void 0||(q.name==="fn"&&e.report({node:q,messageId:"noTypeParameter"}),b.checkImportFunctions&&["importActual","importMock"].includes(q.name)&&e.report({node:q,messageId:"noTypeParameter"}))}}}}),RULE_NAME$5="prefer-called-once",m=e=>e.type===utils.AST_NODE_TYPES.Literal&&e.value===1,jr=createEslintRule({name:RULE_NAME$5,meta:{docs:{description:"enforce using `toBeCalledOnce()` or `toHaveBeenCalledOnce()`",recommended:!1},messages:{preferCalledOnce:"Prefer {{ replacedMatcherName }}()"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const{matcher:Y}=d,q=getAccessorValue(Y);if(["toBeCalledTimes","toHaveBeenCalledTimes"].includes(q)&&d.args.length===1&&m(getFirstMatcherArg(d))){const $=q.replace("Times","Once");e.report({data:{replacedMatcherName:$},messageId:"preferCalledOnce",node:Y,fix:F=>[F.replaceText(Y,$),F.remove(d.args[0])]})}}}}}),RULE_NAME$4="prefer-called-times",Wr=createEslintRule({name:RULE_NAME$4,meta:{docs:{description:"enforce using `toBeCalledTimes(1)` or `toHaveBeenCalledTimes(1)`",recommended:!1},messages:{preferCalledTimes:"Prefer {{ replacedMatcherName }}(1)"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect")return;const{matcher:Y}=d,q=getAccessorValue(Y);if(["toBeCalledOnce","toHaveBeenCalledOnce"].includes(q)){const $=q.replace("Once","Times");e.report({data:{replacedMatcherName:$},messageId:"preferCalledTimes",node:Y,fix:F=>[F.replaceText(Y,$),F.insertTextAfterRange([d.matcher.range[0],d.matcher.range[1]+1],"1")]})}}}}}),RULE_NAME$3="prefer-expect-type-of",g$1={string:"toBeString",number:"toBeNumber",boolean:"toBeBoolean",object:"toBeObject",function:"toBeFunction",symbol:"toBeSymbol",bigint:"toBeBigInt",undefined:"toBeUndefined"},Kr=createEslintRule({name:RULE_NAME$3,meta:{type:"suggestion",docs:{description:"enforce using `expectTypeOf` instead of `expect(typeof ...)`",recommended:!1},schema:[],fixable:"code",messages:{preferExpectTypeOf:'Use `expectTypeOf({{ value }}).{{ matcher }}()` instead of `expect(typeof {{ value }}).toBe("{{ type }}")`'}},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="expect"||d.head.node.parent?.type!==utils.AST_NODE_TYPES.CallExpression)return;const Y=d.head.node.parent,[q]=Y.arguments;if(!q||q.type!==utils.AST_NODE_TYPES.UnaryExpression||q.operator!=="typeof")return;const $=getAccessorValue(d.matcher);if($!=="toBe"&&$!=="toEqual")return;const[F]=d.args;if(!F||F.type!==utils.AST_NODE_TYPES.Literal||typeof F.value!="string")return;const V=F.value,G=g$1[V];if(!G)return;const X=e.sourceCode.getText(q.argument),z=d.modifiers.map(te=>getAccessorValue(te)).join("."),J=z?`.${z}`:"";e.report({node:b,messageId:"preferExpectTypeOf",data:{value:X,matcher:G,type:V},fix(te){return te.replaceText(b,`expectTypeOf(${X})${J}.${G}()`)}})}}}}),RULE_NAME$2="warn-todo",$r=createEslintRule({name:RULE_NAME$2,meta:{docs:{description:"disallow `.todo` usage",recommended:!1},messages:{warnTodo:"The use of `.todo` is not recommended."},type:"suggestion",schema:[]},defaultOptions:[],create(e){return{CallExpression(b){const d=parseVitestFnCall(b,e);if(d?.type!=="describe"&&d?.type!=="test"&&d?.type!=="it")return;const Y=d.members.find(q=>q.type==="Identifier"&&q.name==="todo");Y&&e.report({messageId:"warnTodo",node:Y})}}}}),RULE_NAME$1="prefer-import-in-mock",Jr=createEslintRule({name:RULE_NAME$1,meta:{fixable:"code",type:"suggestion",docs:{description:"prefer dynamic import in mock"},messages:{preferImport:"Replace '{{path}}' with import('{{path}}')"},schema:[]},defaultOptions:[],create(e){return{CallExpression(b){if(b.callee.type!==utils.AST_NODE_TYPES.MemberExpression)return;const{object:d,property:Y}=b.callee;if(d.type!==utils.AST_NODE_TYPES.Identifier||d.name!=="vi"||Y.type!==utils.AST_NODE_TYPES.Identifier)return;const q=Y.name,$=b.arguments[0];q==="mock"&&$&&$.type===utils.AST_NODE_TYPES.Literal&&e.report({messageId:"preferImport",data:{path:$.value},node:b,fix(F){return F.replaceText($,`import('${$.value}')`)}})}}}}),RULE_NAME="prefer-called-exactly-once-with",O=["toHaveBeenCalledOnce","toHaveBeenCalledWith"],A=["mockClear","mockReset","mockRestore"],N=e=>O.some(b=>b===e),B=(e,b)=>e.type!==utils.AST_NODE_TYPES.MemberExpression?null:b.getText(e.object),_=(e,b)=>e.arguments.map(d=>b.getText(d)).join(", "),H=e=>e?.type!=="expect"||e.modifiers.some(b=>getAccessorValue(b)==="not")?null:e,I=e=>{const b=H(e);return b?getAccessorValue(b.matcher):null},g=({callee:e})=>{if(e.type!==utils.AST_NODE_TYPES.MemberExpression)return null;const{object:b}=e;if(b.type!==utils.AST_NODE_TYPES.CallExpression)return null;const[d]=b.arguments;return d.type!==utils.AST_NODE_TYPES.Identifier?null:d.name},L=(e,b)=>{const d=g(e);if(!d)return null;const Y=g(b);return d!==Y?null:d},v=(e,b,d,Y)=>{if(e.type!==utils.AST_NODE_TYPES.ExpressionStatement||e.expression.type!==utils.AST_NODE_TYPES.CallExpression)return!1;const q=e.loc.start.line;if(q<=d||q>=Y)return!1;const{callee:$}=e.expression;if($.type!==utils.AST_NODE_TYPES.MemberExpression)return!1;const{object:F,property:V}=$;return F.type!==utils.AST_NODE_TYPES.Identifier||F.name!==b||V.type!==utils.AST_NODE_TYPES.Identifier?!1:A.some(G=>G===V.name)},k=(e,b,d)=>{const Y=b.loc.start.line,q=d.loc.start.line,[$,F]=Y<q?[Y,q]:[q,Y],V=L(b,d);return V?e.some(G=>v(G,V,$,F)):!1},W=e=>e.callee.type===utils.AST_NODE_TYPES.MemberExpression?e.callee.property:null,Qr=createEslintRule({name:RULE_NAME,meta:{docs:{description:"Prefer `toHaveBeenCalledExactlyOnceWith` over `toHaveBeenCalledOnce` and `toHaveBeenCalledWith`"},messages:{preferCalledExactlyOnceWith:"Prefer {{matcherName}} (/* expected args */)"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){const{sourceCode:b}=e,d=q=>q.filter($=>$.type===utils.AST_NODE_TYPES.ExpressionStatement).flatMap($=>$.expression.type===utils.AST_NODE_TYPES.CallExpression?$.expression:[]),Y=q=>{const $=d(q),F=new Map;for(const V of $){const G=I(parseVitestFnCall(V,e)),X=B(V.callee,b);if(!G||!N(G)||!X)continue;const z=[...F.get(X)??[],{matcherName:G,callExpression:V}];F.set(X,z)}for(const[V,G]of F.entries()){if(G.length!==2||!G.some(re=>re.matcherName==="toHaveBeenCalledOnce"))continue;const X=G.find(re=>re.matcherName==="toHaveBeenCalledWith");if(!X)continue;const z=_(X.callExpression,b),[J,te]=G,Q=W(te.callExpression);if(!Q)continue;const{callExpression:se}=J,{callExpression:Z,matcherName:ee}=te;k(q,se,Z)||e.report({messageId:"preferCalledExactlyOnceWith",node:Q,data:{matcherName:ee},fix(re){const oe=`${b.text.slice(se.parent.range[0],se.range[0])}${V}.toHaveBeenCalledExactlyOnceWith(${z})`,ne=b.getIndexFromLoc({line:Z.parent.loc.start.line,column:0}),ie=b.getIndexFromLoc({line:Z.parent.loc.end.line+1,column:0});return[re.replaceText(se,oe),re.removeRange([ne,ie])]}})}};return{Program(q){Y(q.body)},BlockStatement(q){Y(q.body)}}}}),Te=e=>Object.keys(e).reduce((b,d)=>({...b,[`vitest/${d}`]:e[d]}),{}),be=e=>({plugins:["@vitest"],rules:Object.keys(e).reduce((b,d)=>({...b,[`@vitest/${d}`]:e[d]}),{})}),he={[RULE_NAME$1a]:"warn",[RULE_NAME$19]:"warn",[RULE_NAME$17]:"warn",[RULE_NAME$16]:"warn",[RULE_NAME$13]:"warn",[RULE_NAME$12]:"warn",[RULE_NAME$10]:"warn",[RULE_NAME$$]:"warn",[RULE_NAME$_]:"warn",[RULE_NAME$Z]:"warn",[RULE_NAME$Y]:"warn",[RULE_NAME$W]:"warn",[RULE_NAME$S]:"warn",[RULE_NAME$R]:"warn",[RULE_NAME$Q]:"warn",[RULE_NAME$P]:"warn",[RULE_NAME$O]:"warn",[RULE_NAME$N]:"warn",[RULE_NAME$M]:"warn",[RULE_NAME$L]:"warn",[RULE_NAME$K]:"warn",[RULE_NAME$J]:"warn",[RULE_NAME$I]:"warn",[RULE_NAME$H]:"warn",[RULE_NAME$C]:"off",[RULE_NAME$E]:"warn",[RULE_NAME$D]:"off",[RULE_NAME$B]:"warn",[RULE_NAME$A]:"warn",[RULE_NAME$z]:"warn",[RULE_NAME$y]:"warn",[RULE_NAME$x]:"warn",[RULE_NAME$w]:"warn",[RULE_NAME$v]:"warn",[RULE_NAME$u]:"warn",[RULE_NAME$t]:"warn",[RULE_NAME$s]:"warn",[RULE_NAME$q]:"warn",[RULE_NAME$p]:"warn",[RULE_NAME$o]:"warn",[RULE_NAME$m]:"warn",[RULE_NAME$l]:"warn",[RULE_NAME$k]:"warn",[RULE_NAME$j]:"warn",[RULE_NAME$i]:"warn",[RULE_NAME$h]:"warn",[RULE_NAME$11]:"warn",[RULE_NAME$g]:"warn",[RULE_NAME$f]:"warn",[RULE_NAME$9]:"warn",[RULE_NAME$e]:"warn",[RULE_NAME$d]:"warn",[RULE_NAME$c]:"warn",[RULE_NAME$b]:"warn",[RULE_NAME$a]:"warn",[RULE_NAME$8]:"warn",[RULE_NAME$15]:"warn",[RULE_NAME$18]:"warn",[RULE_NAME$X]:"warn",[RULE_NAME$G]:"warn",[RULE_NAME$F]:"warn",[RULE_NAME$r]:"warn",[RULE_NAME$n]:"warn",[RULE_NAME$V]:"warn",[RULE_NAME$7]:"warn",[RULE_NAME$6]:"warn",[RULE_NAME$U]:"off",[RULE_NAME$T]:"warn",[RULE_NAME$5]:"off",[RULE_NAME$4]:"warn",[RULE_NAME$3]:"warn",[RULE_NAME$14]:"warn",[RULE_NAME$1]:"warn",[RULE_NAME]:"warn"},ge={[RULE_NAME$15]:"error",[RULE_NAME$18]:"error",[RULE_NAME$X]:"error",[RULE_NAME$G]:"error",[RULE_NAME$F]:"error",[RULE_NAME$r]:"error",[RULE_NAME$n]:"error",[RULE_NAME$V]:"error",[RULE_NAME]:"error"},Xr={[RULE_NAME$1a]:xe,[RULE_NAME$19]:Ce,[RULE_NAME$18]:ve,[RULE_NAME$17]:Be,[RULE_NAME$16]:Ie,[RULE_NAME$15]:ye,[RULE_NAME$14]:Oe,[RULE_NAME$13]:Se,[RULE_NAME$12]:De,[RULE_NAME$11]:He,[RULE_NAME$10]:qe,[RULE_NAME$$]:Fe,[RULE_NAME$_]:Ve,[RULE_NAME$Z]:Pe,[RULE_NAME$Y]:Ge,[RULE_NAME$X]:je,[RULE_NAME$W]:We,[RULE_NAME$S]:Je,[RULE_NAME$R]:Qe,[RULE_NAME$Q]:Xe,[RULE_NAME$P]:Ye,[RULE_NAME$O]:Ze,[RULE_NAME$N]:er,[RULE_NAME$M]:rr,[RULE_NAME$L]:or,[RULE_NAME$K]:ar,[RULE_NAME$J]:tr,[RULE_NAME$I]:nr,[RULE_NAME$V]:Ke,[RULE_NAME$H]:sr,[RULE_NAME$G]:ir,[RULE_NAME$F]:mr,[RULE_NAME$C]:fr,[RULE_NAME$E]:pr,[RULE_NAME$D]:Er,[RULE_NAME$B]:lr,[RULE_NAME$A]:Nr,[RULE_NAME$z]:cr,[RULE_NAME$y]:dr,[RULE_NAME$x]:Ar,[RULE_NAME$w]:Mr,[RULE_NAME$v]:wr,[RULE_NAME$n]:hr,[RULE_NAME$u]:Rr,[RULE_NAME$t]:Lr,[RULE_NAME$s]:ur,[RULE_NAME$r]:Ur,[RULE_NAME$q]:_r,[RULE_NAME$p]:Tr,[RULE_NAME$o]:br,[RULE_NAME$m]:gr,[RULE_NAME$l]:kr,[RULE_NAME$k]:xr,[RULE_NAME$j]:Cr,[RULE_NAME$i]:vr,[RULE_NAME$h]:Br,[RULE_NAME$g]:Ir,[RULE_NAME$f]:yr,[RULE_NAME$9]:Or,[RULE_NAME$e]:Sr,[RULE_NAME$d]:Dr,[RULE_NAME$c]:Hr,[RULE_NAME$b]:qr,[RULE_NAME$a]:Fr,[RULE_NAME$8]:Vr,[RULE_NAME$7]:Pr,[RULE_NAME$6]:Gr,[RULE_NAME$U]:$e,[RULE_NAME$T]:ze,[RULE_NAME$5]:jr,[RULE_NAME$4]:Wr,[RULE_NAME$3]:Kr,[RULE_NAME$2]:$r,[RULE_NAME$1]:Jr,[RULE_NAME]:Qr},l={meta:{name:"vitest",version},rules:Xr,environments:{env:{globals:{suite:!0,test:!0,describe:!0,it:!0,expectTypeOf:!0,assertType:!0,expect:!0,assert:!0,chai:!0,vitest:!0,vi:!0,beforeAll:!0,afterAll:!0,beforeEach:!0,afterEach:!0,onTestFailed:!0,onTestFinished:!0}}},configs:{"legacy-recommended":be(ge),"legacy-all":be(he),recommended:{name:"vitest/recommended",plugins:{get vitest(){return l}},rules:Te(ge)},all:{name:"vitest/all",plugins:{get vitest(){return l}},rules:Te(he)},env:{name:"vitest/env",languageOptions:{globals:{suite:"writable",test:"writable",describe:"writable",it:"writable",expectTypeOf:"writable",assertType:"writable",expect:"writable",assert:"writable",chai:"writable",vitest:"writable",vi:"writable",beforeAll:"writable",afterAll:"writable",beforeEach:"writable",afterEach:"writable",onTestFailed:"writable",onTestFinished:"writable"}}}}};module.exports=l;
